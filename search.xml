<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>多线程资源共享</title>
      <link href="/2022/02/24/xian-cheng-zi-yuan-gong-xiang/"/>
      <url>/2022/02/24/xian-cheng-zi-yuan-gong-xiang/</url>
      
        <content type="html"><![CDATA[<h1 id="c-线程资源共享"><a href="#c-线程资源共享" class="headerlink" title="c++线程资源共享"></a>c++线程资源共享</h1><p>我们知道，在多线程中，如果两个线程都使用到了同一份资源，那么这两个线程对资源修改和使用的先后顺序是不确定的。</p><p>比如有一副1024*1280的图像，一个线程需要不断地更新图像，另一个线程需要使用这个图像并且将其显示出来。如果修改图像的线程运行到一半的时候，显示图像的线程就将数据提取出来显示，那么就可能产生图像残缺的现象。这会对我们的应用产生不可预测的结果。这种线程相互争夺资源的现象，被称为线程不安全。</p><p>要想安全地使用资源，那么就必须设计一定的规则，使得到资源的线程处理；没有得到资源的线程休眠，以此达到线程安全和充分利用cpu的目的。</p><hr><h2 id="使用互斥锁mutex"><a href="#使用互斥锁mutex" class="headerlink" title="使用互斥锁mutex"></a>使用互斥锁mutex</h2><p><a href="https://qingcms.gitee.io/cppreference/20210212/zh/cpp/thread/mutex.html">c++ mutex使用手册</a></p><p>基础用法：</p><pre class=" language-cpp"><code class="language-cpp">    std<span class="token operator">::</span>mutex your_mutex<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//定义你的锁</span>    your_mutex<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//上锁</span>    <span class="token comment" spellcheck="true">//使用你的资源</span>    your_mutex<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre><p>注意同一份资源应该使用同一个锁</p><p>当一个线程调用这个锁对象的lock()函数之后，如果第二个线程也调用了lock函数，那么第二个线程就会”被迫等待”，类似于进入一个while循环，直到第一个线程调用unlock()函数。</p><p>使用互斥锁之后，就能保证每一个时刻都最多只有一个线程在处理这份资源。</p><p>mutex的缺点：等待资源的线程会频繁唤醒cpu，导致程序的性能下降。</p><hr><h2 id="条件变量-智能锁"><a href="#条件变量-智能锁" class="headerlink" title="条件变量+智能锁"></a>条件变量+智能锁</h2><p><a href="https://www.apiref.com/cpp-zh/cpp/thread/condition_variable.html">c++ 条件变量使用手册</a></p><p><a href="https://www.apiref.com/cpp-zh/cpp/thread/unique_lock.html">c++ unique_lock使用手册</a></p><p>使用互斥锁可能会造成死锁的情况，即上锁之后忘记解锁，导致资源一直不能释放，等待资源的线程卡死。</p><p>使用互斥锁导致频繁唤醒cpu会导致性能消耗极大。</p><p>使用条件变量和智能锁能一定程度上解决这些问题</p><p>使用智能锁unique_lock能够在这把锁的声明周期过后自动释放，故避免了死锁的问题</p><p>使用条件变量，当生产者生产完之后，给消费者一个信号，消费者才可以进行处理，否则的话，消费者会一直休眠。使用这种方法，降低了唤醒cpu的频率。导致程序的性能提高。</p><p>有了条件变量还需要使用锁的原因是条件变量可能会误唤醒，加锁是第二层保障</p><p>基本使用(生产者)</p><pre class=" language-cpp"><code class="language-cpp">    std<span class="token operator">::</span>condition_variable cond<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//cond为线程之间共享的变量</span>    <span class="token punctuation">{</span>        std<span class="token operator">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">></span> my_lock<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//生产资源</span>        cond<span class="token punctuation">.</span><span class="token function">notify_one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//唤醒等待的线程</span>    <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//过了unique_lock的生命周期之后，锁自动释放</span></code></pre><pre class=" language-cpp"><code class="language-cpp">    std<span class="token operator">::</span>condition_variable cond<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//cond为线程之间共享的变量</span>    <span class="token punctuation">{</span>        std<span class="token operator">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">></span> my_lock<span class="token punctuation">;</span>        cond<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//等待资源</span>        <span class="token comment" spellcheck="true">//消费资源</span>    <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//过了unique_lock的生命周期之后，锁自动释放</span></code></pre><p>条件变量和智能锁一定程度上提高了程序的性能，但由于还带锁，锁造成的低性能仍然没有发生本质上的改变。如果要使程序处于无锁的良好环境，减少数据竞争的话，需要使用到原子变量的无锁编程。</p><hr><h2 id="无锁循环队列"><a href="#无锁循环队列" class="headerlink" title="无锁循环队列"></a>无锁循环队列</h2><p><a href="https://www.apiref.com/cpp-zh/cpp/atomic/atomic.html">c++ atomic使用手册</a></p><p>要很好地理解以下的代码，就先要了解原子变量内存模型。某个语句f中的一个变量a在下面代码有依赖的意思是下面某句代码g直接或者间接用到了变量a,故编译器会自动将g代码语句放在f后面。否则的话编译器可以自动安排语句的执行顺序，来提高代码的运行效率。</p><p>以下代码适用于生产者-消费者模型</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">ifndef</span> _LOCKFREE_QUEUE_</span><span class="token macro property">#<span class="token directive keyword">define</span> _LOCKFREE_QUEUE_</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;atomic></span>   </span><span class="token comment" spellcheck="true">//原子标准库</span><span class="token macro property">#<span class="token directive keyword">define</span> FIXED_NUM 16 </span><span class="token comment" spellcheck="true">//设置为2的整数次方 方便处理，因为对2的整数次方作除法可以用左移表示</span>    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span> <span class="token comment" spellcheck="true">//模板类，T为你需要共享的数据类型</span>    <span class="token keyword">class</span> <span class="token class-name">LockFreeQueue</span>    <span class="token punctuation">{</span>        <span class="token keyword">struct</span> Element        <span class="token punctuation">{</span>            T data_<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//数据存储区</span>            std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> is_full<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//是否有数据</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token function">LockFreeQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">~</span><span class="token function">LockFreeQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">bool</span> <span class="token function">push</span><span class="token punctuation">(</span>T <span class="token operator">&amp;</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//入栈</span>        <span class="token keyword">bool</span> <span class="token function">pop</span><span class="token punctuation">(</span>T <span class="token operator">&amp;</span>output<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//出栈</span>        std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">short</span><span class="token operator">></span> write_index<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//写索引</span>        Element data_queue<span class="token punctuation">[</span>FIXED_NUM<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//固定大小的数组，通过write_index构成循环队列的效果</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>    LockFreeQueue<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">LockFreeQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        write_index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//初始化为0</span>    <span class="token punctuation">}</span>    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>    LockFreeQueue<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token operator">~</span><span class="token function">LockFreeQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>    <span class="token keyword">bool</span> LockFreeQueue<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">push</span><span class="token punctuation">(</span>T <span class="token operator">&amp;</span>input<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//由于后面的语句都对write_index_temp有依赖，故此处的内存模型可以忽略，或者说用什么都行</span>        <span class="token keyword">short</span> write_index_temp <span class="token operator">=</span> write_index<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token operator">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span>        data_queue<span class="token punctuation">[</span>write_index_temp<span class="token punctuation">]</span><span class="token punctuation">.</span>data_ <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//利用std::move可以加快处理速度，移动过后的对象input不再可用</span>        <span class="token comment" spellcheck="true">//memory_order_release内存模型强制前一条语句在这一条之前运行，即必须要修改完data_再将is_full置true</span>        data_queue<span class="token punctuation">[</span>write_index_temp<span class="token punctuation">]</span><span class="token punctuation">.</span>is_full<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> std<span class="token operator">::</span>memory_order<span class="token operator">::</span>memory_order_release<span class="token punctuation">)</span><span class="token punctuation">;</span>        write_index_temp<span class="token operator">++</span><span class="token punctuation">;</span>         write_index_temp <span class="token operator">%</span><span class="token operator">=</span> FIXED_NUM<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//构成循环</span>        <span class="token comment" spellcheck="true">//强制使write_index_temp修改后再运行，但其实由于write_index_temp用到了write_index_temp,故即使不用memory_order_release模型，也会在write_index_temp自增之后运行</span>        write_index<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span>write_index_temp<span class="token punctuation">,</span> std<span class="token operator">::</span>memory_order<span class="token operator">::</span>memory_order_release<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>    <span class="token keyword">bool</span> LockFreeQueue<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">pop</span><span class="token punctuation">(</span>T <span class="token operator">&amp;</span>output<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//索引到读取index的前一个，更好地达到同步的效果</span>        <span class="token keyword">short</span> read_index <span class="token operator">=</span> write_index<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token operator">::</span>memory_order<span class="token operator">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span>        read_index <span class="token operator">=</span> <span class="token punctuation">(</span>read_index <span class="token operator">+</span> FIXED_NUM <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> FIXED_NUM<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//强制后面的语句在这一条语句之后运行,即必须要is_full为true才执行后面的代码</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>data_queue<span class="token punctuation">[</span>read_index<span class="token punctuation">]</span><span class="token punctuation">.</span>is_full<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token operator">::</span>memory_order_acquire<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            output <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>data_queue<span class="token punctuation">[</span>read_index<span class="token punctuation">]</span><span class="token punctuation">.</span>data_<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//强制前面的代码在这句代码之前执行</span>            data_queue<span class="token punctuation">[</span>read_index<span class="token punctuation">]</span><span class="token punctuation">.</span>is_full<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> std<span class="token operator">::</span>memory_order<span class="token operator">::</span>memory_order_release<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token macro property">#<span class="token directive keyword">endif</span></span></code></pre><p>使用以上代码，当生产资源时，使用push函数；当消费资源时，使用pop函数</p>]]></content>
      
      
      <categories>
          
          <category> RoboMaster </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RoboMaster </tag>
            
            <tag> c++ </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学建模与应用总结</title>
      <link href="/2022/02/16/shu-xue-jian-mo-yu-ying-yong-zong-jie/"/>
      <url>/2022/02/16/shu-xue-jian-mo-yu-ying-yong-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="数学建模算法与应用算法分类与总结"><a href="#数学建模算法与应用算法分类与总结" class="headerlink" title="数学建模算法与应用算法分类与总结"></a>数学建模算法与应用算法分类与总结</h1><h2 id="模型建立方法以及流程"><a href="#模型建立方法以及流程" class="headerlink" title="模型建立方法以及流程"></a>模型建立方法以及流程</h2><ol><li><p>问题分析</p><p>简述问题的意思，明确问题处理的思路</p></li><li><p>模型假设</p><p>通常为8-10条，给出模型在什么条件下成立</p></li><li><p>符号说明</p></li><li><p>模型建立</p><p> 给出一定的公式，推到出相应的最终表达式</p></li><li><p>模型求解</p></li><li><p>灵敏度分析</p><p> 已经假设固定的变量，实际上并不是固定的，要给定其一定的上下波动范围来对其进行求解</p></li><li><p>结果分析以及得出结论</p></li></ol><h2 id="规划类"><a href="#规划类" class="headerlink" title="规划类"></a>规划类</h2><ul><li><p>线性规划</p><ul><li><p>线性规划模型通常在题目中表现会比较明显,不过多赘述(书本$P_1$)</p></li><li><p>可转为线性规划的形式(书本$P_8$)</p></li></ul><p>  $$ \min \lvert x_1 \rvert + \lvert x_2 \rvert +\lvert x_3 \rvert + … + \lvert x_n \rvert \<br>  s.t. Ax \leq b<br>  $$</p><ul><li><p>带有绝对值的min max类非线性规划，可以使用手工线性化之后使用软件求解(书本$P_9$)</p></li><li><p>线性求解参考代码$P_{14}$</p></li></ul></li><li><p>整数规划</p><ul><li><p>适宜解决的问题</p><ol><li><p>符合线性规划的形式且带整数约束的规划问题</p></li><li><p>要么是1要么是0的0-1规划问题(使用或不使用)</p></li><li><p>路线规划问题(也用于图论)，即进入一个地方则$x_{ij}&#x3D;1$,否则$x_{ij}&#x3D;0$ ($P_{20}$)</p></li><li><p>引入充分大的数构成约束来达到选择的效果($P_{21}$)</p></li><li><p>混合整数规划问题，比如如果不采用a方案，那么a方案的产出$x_a&#x3D;0$,这时候可以使用($P_{22}$)</p></li></ol></li><li><p>代码参考$P_{26}$</p></li><li><p>利用蒙卡特洛方法可以很好地对非线性整数规划问题进行求解($P_{27}$)</p></li></ul></li><li><p>非线性规划</p><ul><li><p>无约束非线性优化的求解($P_{38}$),利用海塞尔矩阵求解</p></li><li><p>带约束非线性优化的求解思路，通常是线性化为非线性,带约束化为无约束</p><ol><li><p>只有等式约束的时候，可以采用拉格朗日乘数法($P_{39}$)</p></li><li><p>当同时含有等式约束和不等式约束时，可以采用罚函数法($P_{39}$)</p></li></ol></li><li><p>凸规划($P_{40}$)</p><ul><li><p>凸规划是求解式子为凸函数，不等式约束为凸函数，等式约束为线性函数的规划，线性规划是特殊的凸规划,凸规划局部最优解即为全局最优解</p></li><li><p>KT条件用来判断凸规划的解x是否是全局最优解</p></li></ul></li><li><p>例子($P_{42} , P_{56}$)</p></li><li><p>二次规划</p><ul><li>决策变量为二次函数，而约束条件为线性函数的模型(P_{48})</li></ul></li><li><p>非线性规划代码介绍($P_{49}$)</p></li></ul></li></ul><h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2><ul><li><p>Matlab生成图($P_{65}$)</p></li><li><p>典型的寻路算法(Dijkstra,Floyd)($P_{67}$)</p></li><li><p>最短路问题的0-1整数规划模型，见整数规划($P_{74}$)</p></li><li><p>最小生成树算法($P_{75}$)Prim,Kruskal算法，最小生成树的整数规划模型($P_{78}$)</p></li><li><p>最大流算法:所谓最大流算法指的是在流进等于流出的条件之下，整个图允许通过的最大容量(不包含始末),最大流算法可以写作整数规划模型来求解($P_{82}$),也可以使用标号法Ford-Fulkerson算法来实现($P_{83}$)</p></li><li><p>最小费用流算法：考虑到达终点所需要的最小花费的算法，一般和最大流算法一起使用，一般转化为线性规划来求解，也可以使用迭代法来求解($P_{84}$)</p></li><li><p>改良圈算法：即不重复经过同一个节点，且使得总路程最短的解算算法($P_{88}$)，这个问题也可以用整数规划模型来解决</p></li><li><p>关键路径求解：可以将关键路径看成最长路径来进行求解$P_{96}$，也可以根据最早开工时间和最晚开工时间迭代求解$P_{97}$</p></li><li><p>实际上工作时间可能会随着客观因素而变动，利用$P_{100}$的算法来计算能够按时完成任务的概率</p></li></ul><h2 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h2><ul><li><p>特性：插值可以对区间之外的部分作出短期预测，长期预测可能失效较为严重</p></li><li><p>多项式插值($P_{114}$)</p><ul><li><p>待定系数法，用于观测点数目和约束方程数量一致的情况($P_{114}$) </p></li><li><p>拉格朗日插值法，一般实际应用意义不是很大($P_{115}$)   </p></li><li><p>牛顿插值法，一般实际应用意义不大($P_{116}$)</p></li></ul></li><li><p>分段线性化方法插值，多项式高次插值导致产生龙格震荡现象，故利用分段线性化可以更好地拟合出真正地曲线($P_{119}$)</p></li><li><p>三次样条插值：分段线性化的插值会导致取样点处的导数不存在,三次插值实际上是利用节点处的一阶和二阶导数相等来待定系数求解($P_{119}$)</p></li><li><p>二次插值</p><ul><li><p>网格节点插值法($P_{121}$)</p><ul><li><p>最临近点插值，即某一点与这一点所处于的区间最接近的有值的一点函数值相同</p></li><li><p>分片线性插值</p></li><li><p>双线性插值</p></li></ul></li><li><p>散乱数据插值方法，对一群离散点进行插值($P_{122}$)</p></li></ul></li></ul><h2 id="拟合"><a href="#拟合" class="headerlink" title="拟合"></a>拟合</h2><ul><li><p>最小二乘法拟合(线性与非线性)($P_{132}$)</p></li><li><p>拟合函数选择($P_{133}$)</p></li><li><p>拟合可以使用Matlab工具箱，参考($P_{133}$)</p></li><li><p>曲线与曲面拟合($P_{141}$)</p></li><li><p>拟合或统计的判断方法($P_{143}$)</p></li><li><p>函数逼近($P_{143}$)</p></li></ul><h2 id="微分方程"><a href="#微分方程" class="headerlink" title="微分方程"></a>微分方程</h2><ul><li><p>用途：可用于每一时刻的状态变化和下一时刻状态变化密切相关的场合，比如传染病模型，传染人数和感染人数相关</p></li><li><p>传播可以采用指数传播模型($P_{153}$)</p></li><li><p>三种典型的传染病模型($P_{154}$)</p><ul><li><p>SI模型，不考虑治愈以及免疫</p></li><li><p>SIS模型考虑病人治愈</p></li><li><p>SIR模型考虑治愈以及免疫之后退出感染系统</p></li></ul></li><li><p>微分方程求解($P_{159}$)</p></li><li><p>Lorenz模型的混沌效应:具有初值敏感性(不知道有什么用)($P_{161}$)</p></li><li><p>边值问题求解($P_{166}$)</p></li><li><p>人口预测模型</p><ul><li><p>Malthus模型，人口预测模型，假设人口的增长率不变($P_{170}$)</p></li><li><p>Logistic模型，人口的增长率是与人口数量有关($P_{171}$)</p></li></ul></li><li><p>种群相互作用模型</p><ul><li><p>种群竞争模型($P_{173}$)</p></li><li><p>弱肉强食模型($P_{174}$)</p></li></ul></li></ul><h2 id="数理统计"><a href="#数理统计" class="headerlink" title="数理统计"></a>数理统计</h2><ul><li><p>区间估计:即估计在某一区间内的数占总量的百分之几，注意均值和方差是否已知($P_{182}$)</p></li><li><p>双变量联合分布求置信区间示例($P_{184}$)</p></li><li><p>经验分布函数的使用($P_{184}$)</p></li><li><p>Q-Q图检验拟合优度，即检验某个随机变量是否符合你所预估的分布($P_{185}$)</p></li><li><p>非参数检验</p><ul><li><p>卡方拟合优度检验：检验总体X是否满足某个概率密度($P_{187}$)</p></li><li><p>柯尔莫哥洛夫检验：基于经验分布函数检验理论分布函数与样本分布函数的拟合优度($P_{191}$)</p></li><li><p>秩和检验：检验两个分布总体分布是否有明显差异($P_{192}$)</p></li></ul></li><li><p>Bootstrap方法：抽取很多个样本，利用样本对总体进行统计推断</p><ul><li><p>标准误差的Bootstrap估计($P_{194}$)</p></li><li><p>均方误差的Bootstrap估计($P_{196}$)</p></li><li><p>Bootstrap求解置信区间($P_{197}$)</p></li><li><p>分布函数形式已知，但部分参数未知，可以利用Bootstrap进行参数估计($P_{198}$)</p></li></ul></li><li><p>均值检验：比较两个总体的均值($P_{201}$),不用于多于两个总体</p></li><li><p>单因素方差分析：仅仅考虑一个因素，其它因素不变，用来判断该因素对总体的影响($P_{202}$)</p></li><li><p>双因素方差分析：考虑两个因素对总体的影响，包括无交互影响的双因素方差分析($P_{207}$)和有交互影响的方差分析($P_{208}$)</p></li><li><p>回归分析</p><ul><li><p>多元线性回归</p><ul><li><p>参数估计($P_{211}$)</p></li><li><p>对统计变量的残差，期望，方差进行分析($P_{212}$)</p></li><li><p>回归模型的假设检验,检验变量是否符合该多元线性关系，排除多出维度参数的可能($P_{213}$)</p></li><li><p>回归系数的假设检验和区间估计，即排除部分维度，找出拟合最好的维度，舍去贡献度很小的维度($P_{213}$)</p></li><li><p>回归模型预测($P_{214}$)</p></li></ul></li><li><p>多元二次项回归($P_{214}$)</p></li><li><p>非线性回归($P_{218}$)</p></li><li><p>逐步回归：多因素，使用关联性强的因素选入模型进行回归，舍去关联性不强的因素</p><ul><li><p>前进法，每次增加一个因素，然后使用显著性P值来检验新因素的影响($P_{220}$)</p></li><li><p>后退法，每次减少一个因素，然后使用显著性P值来检验新因素的影响($P_{221}$)</p></li><li><p>逐步回归法，每增加一个因素，就要对所有因素进行一次检验，解得的集合为最优回归子集($P_{221}$)</p></li></ul></li></ul></li><li><p>灰色模型和Bootstrap理论</p><ul><li><p>用途：小样本，数据预测，统计推断，对分布参数进行较为精确的区间估计，不需要知道原有数据的分布($P_{222}$)</p></li><li><p>灰色模型建立($P_{223}$)</p></li><li><p>Bootstrap分析：重发取样，求得统计量的经验分布并进行区间估计($P_{224}$)</p></li></ul></li></ul><h2 id="差分方程"><a href="#差分方程" class="headerlink" title="差分方程"></a>差分方程</h2><ul><li><p>特点：通过递推关系求得状态之间的关联</p></li><li><p>差分方程建模($P_{231}$)</p></li><li><p>Leslie种群模型：求年龄分布和种群增长的规律，有明显的递推关系特征</p></li></ul><h2 id="分类问题"><a href="#分类问题" class="headerlink" title="分类问题"></a>分类问题</h2><ul><li><p>支持向量机($P_{248}$)</p></li><li><p>Q型据类分析($P_{262}$)，对样本进行分类</p></li></ul><h2 id="多元分析"><a href="#多元分析" class="headerlink" title="多元分析"></a>多元分析</h2><ul><li><p>聚类分析</p><ul><li><p>Q型聚类分析，样本分类</p></li><li><p>R型聚类，用于变量分类，便于理清变量之间的关系，然后通过这个关系来选择关键因素进行模型建立($P_{269}$)</p></li></ul></li><li><p>主成分分析($P_{279}$)</p><ul><li><p>特点：是一种降维方法，去除很多无关的变量，提取主要变量</p></li><li><p>主成分回归分析：将回归自变量变换到另一组变量，提取主成分之后再进行逆变换之后得出参数估计</p></li></ul></li><li><p>因子分析：和主成分分析的目的相同，都是特征降维($P_{285}$)</p></li><li><p>因子分析与主成分分析对比($P_{296}$)</p></li><li><p>判别分析：使用研究个体的观察指标来判断个体的类型($P_{303}$)</p><ul><li><p>距离判断($P_{304}$)</p></li><li><p>Fisher判别($P_{306}$)</p></li><li><p>Bayes判别($P_{307}$)</p></li></ul></li><li><p>典型相关分析：用来研究两组变量的相关关系($P_{313}$)</p></li><li><p>对应分析：再因子分析的基础之上，解决因子分析求解速度很慢的问题($P_{328}$)</p></li><li><p>多维标度法：n个指标反映的东西是模糊的，通过这几个指标的距离，反映他们之间的关系($P_{344}$)</p></li></ul><h2 id="偏最小二乘回归分析"><a href="#偏最小二乘回归分析" class="headerlink" title="偏最小二乘回归分析"></a>偏最小二乘回归分析</h2><ul><li>通过从自变量和因变量中提取成分来求解多对多的回归建模($P_{355}$)</li></ul><h2 id="现代优化算法"><a href="#现代优化算法" class="headerlink" title="现代优化算法"></a>现代优化算法</h2><ul><li><p>模拟退火算法($P_{367}$)</p></li><li><p>遗传算法($P_{373}$)</p></li></ul><h2 id="综合评价和决策方法"><a href="#综合评价和决策方法" class="headerlink" title="综合评价和决策方法"></a>综合评价和决策方法</h2><ul><li><p>确定多属性的权值算法</p><ul><li><p>TOPSIS算法：通过距离正理想解和负理想解的距离来判断($P_{411}$)</p></li><li><p>模糊综合方法：不受主观因素影响，可用于人才资源评测($P_{416}$)</p></li></ul></li><li><p>数据包络分析：对多指标输入和多指标输出有效($P_{410}$)</p></li><li><p>灰色关联分析($P_{424}$)</p></li><li><p>主成分分析($P_{427}$)</p></li><li><p>秩和比综合评价($P_{430}$)</p></li><li><p>熵权法评价($P_{432}$)</p></li><li><p>PageRank算法：搜索引擎检测结果排序算法($P_{434}$)</p></li></ul><h2 id="预测方法"><a href="#预测方法" class="headerlink" title="预测方法"></a>预测方法</h2><ul><li><p>根据已有数据对未来一段时间的数据进行预测</p></li><li><p>微分方程模型($P_{448}$)</p></li><li><p>灰色预测模型($P_{450}$)</p></li><li><p>马尔可夫预测模型：下一步发生的概率与历史的数据无关，仅仅与当前位置有关($P_{460}$)</p></li><li><p>时间序列</p><ul><li>检验时间序列是否平稳的Daniel算法($P_{466}$)</li></ul></li><li><p>插值与拟合($P_{469}$)</p></li><li><p>神经网络($P_{473}$)</p></li><li><p>通过元胞自动机来模拟传播并且进行预测</p></li></ul><h2 id="多目标规划"><a href="#多目标规划" class="headerlink" title="多目标规划"></a>多目标规划</h2><ul><li>即有多个目标函数，求解对于所有目标函数最小或者最大的最优解问题</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 美赛 </tag>
            
            <tag> 数学建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>弹道方程以及代码实现</title>
      <link href="/2022/02/15/dan-dao-fang-cheng-yuan-li/"/>
      <url>/2022/02/15/dan-dao-fang-cheng-yuan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="弹道方程以及代码实现"><a href="#弹道方程以及代码实现" class="headerlink" title="弹道方程以及代码实现"></a>弹道方程以及代码实现</h1><h2 id="什么是弹道方程？"><a href="#什么是弹道方程？" class="headerlink" title="什么是弹道方程？"></a>什么是弹道方程？</h2><p>弹道方程，就是使用数学模型来量化子弹在空气阻力作用下的运动轨迹。这听起来十分复杂，但其实际上其算法核心是依托于我们初中学过的斜抛运动,并没有想象之中的那么深奥。</p><p><img src="/2022/02/15/dan-dao-fang-cheng-yuan-li/1.png" alt="弹道示意图"></p><p>现在，我们假设子弹从A点出发，需要击打B点，在重力加速度和空气阻力的作用下，我们不可能使子弹的初速度直接指向AB方向，而是使子弹的发射方向偏离AC方向$\alpha$角度，这样才能确保子弹能以优美的弧线直接击打中B点。弹道方程的核心便是求解$\alpha$角</p><h2 id="忽略空气阻力的弹道方程建模"><a href="#忽略空气阻力的弹道方程建模" class="headerlink" title="忽略空气阻力的弹道方程建模"></a>忽略空气阻力的弹道方程建模</h2><ol><li><p>首先对初速度V进行速度分解</p><p> $$<br> \begin{cases}<br>     v_x&#x3D;v\cos\alpha \<br>     v_y&#x3D;v\sin\alpha<br> \end{cases}<br> $$</p></li><li><p>由于水平上不受力的作用(忽略了空气阻力),故</p><ul><li><p>飞行时间 $t&#x3D;\frac{f}{v_x}&#x3D;\frac{f}{v\cos\alpha}$ (f为如图的水平距离)</p></li><li><p>子弹击打中的高度<br> $$<br>  h &#x3D; v_y t - \frac{1}{2} g t^2&#x3D;v \sin \alpha * \frac{f}{v \cos \alpha} - \frac{1}{2} g * (\frac{f}{v \cos \alpha})^2&#x3D;f \tan \alpha - \frac{1}{2} g * (\frac{f}{v \cos \alpha})^2<br> $$</p></li></ul></li><li><p>求解：先来分析已知条件以及目的参数，我们已经计算得到了B点相对于A点的位置，那么h和f已知，有重力加速度已知，目标是求解$\alpha$,这容易得到$\alpha$的解析式，下面利用高斯牛顿法迭代求解$\alpha$</p></li><li><p>高斯牛顿法求解方程</p><ul><li><p>首先构造残差函数</p><p>  $$<br>  \lvert\lvert e \rvert\rvert ^2 &#x3D; \lvert\lvert h_{actual}-h_{calc} \rvert\rvert ^2<br>  $$</p><p>  其中$ h_{actual} $ 为已知值， $ h_{calc} $ 是使用迭代法逐渐逼近的h值</p><p>  我们的目标是</p><p>  $$<br>  \min \lvert\lvert e \rvert\rvert ^2 &#x3D; \lvert\lvert h_{actual}-h_{calc} \rvert\rvert ^2 &#x3D; \lvert\lvert h_{actual} - f\tan\alpha+\frac{1}{2}g*(\frac{f}{v\cos\alpha})^2 \rvert\rvert ^2<br>  $$</p><p>  以此来达到使用计算机迭代逼近$ h_{actual} $的目的</p></li><li><p>对误差函数e进行泰勒展开，则：</p><p>  $$<br>  e(\alpha + \Delta\alpha)&#x3D;e(\alpha)+\frac{\delta e}{\delta \alpha} * \Delta \alpha<br>  $$</p></li><li><p>那么近似的误差函数可以写为(对内部进行泰勒展开并且将整个式子展开)</p><p>  $$<br>  \lvert\lvert e(\alpha + \Delta\alpha) \rvert\rvert ^2 &#x3D; e^2 + 2e \frac{\delta e}{\delta \alpha} \Delta\alpha + (\frac{\delta e}{\delta \alpha} )^2 (\Delta \alpha)^2<br>  $$</p></li><li><p>对于这个方程,$ e(\alpha + \Delta\alpha) $ 表示当e加上一个微小变量时e的变化幅度，当e最小时，有那么$ \frac {d e(\alpha + \Delta\alpha)}{d \Delta \alpha} &#x3D; 0 $ ,解得 </p><p>  $$<br>  \Delta \alpha &#x3D; -\frac{e}{\frac{\delta e}{\delta\alpha}}<br>  $$</p></li><li><p>$\Delta \theta$变化的方向是使误差函数趋于最小值的方向，那么</p><p>  $$<br>  \alpha_{updata}&#x3D; \alpha + \Delta\alpha<br>  $$</p></li></ul></li><li><p>完整流程图</p></li></ol><p><img src="/2022/02/15/dan-dao-fang-cheng-yuan-li/2.png" alt="牛顿法迭代流程图"></p>]]></content>
      
      
      <categories>
          
          <category> RoboMaster </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RoboMaster </tag>
            
            <tag> 算法 </tag>
            
            <tag> 辅瞄 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
