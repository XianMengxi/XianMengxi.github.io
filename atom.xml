<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>闲居</title>
  
  
  <link href="https://xianmengxi.github.io/atom.xml" rel="self"/>
  
  <link href="https://xianmengxi.github.io/"/>
  <updated>2023-08-20T06:29:45.882Z</updated>
  <id>https://xianmengxi.github.io/</id>
  
  <author>
    <name>闲梦溪</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://xianmengxi.github.io/2023/11/21/lun-tui-ping-heng-bu-bing-zong-jie-ji-jie-she-ji-pian/lun-tui-ping-heng-bu-bing-zong-jie-ji-jie-she-ji-pian/"/>
    <id>https://xianmengxi.github.io/2023/11/21/lun-tui-ping-heng-bu-bing-zong-jie-ji-jie-she-ji-pian/lun-tui-ping-heng-bu-bing-zong-jie-ji-jie-she-ji-pian/</id>
    <published>2023-11-21T11:38:04.722Z</published>
    <updated>2023-08-20T06:29:45.882Z</updated>
    
    <content type="html"><![CDATA[<h1 id="轮腿平衡步兵总结-机械设计篇"><a href="#轮腿平衡步兵总结-机械设计篇" class="headerlink" title="轮腿平衡步兵总结 - 机械设计篇"></a>轮腿平衡步兵总结 - 机械设计篇</h1><h2 id="轮子设计"><a href="#轮子设计" class="headerlink" title="轮子设计"></a>轮子设计</h2><p>先看一下不能上场的轮子长什么样</p><img src="./1.jpg" width = "300" height = "200" alt="图片名称" align=center /><p>再来看看能上场的轮子长什么样</p><img src="./2.jpg" width = "300" height = "200" alt="图片名称" align=center /><p>两个图中可以很明显看出区别为能上场的轮子会比较薄，当其踩到大弹丸可以碾压过去，而较宽的轮子则无论如何也过不了大弹丸。</p><p>另一个关键特性是轮子的半径，轮子半径越大，其越野性能越好，但RM赛场上需要的越野性能不需要特别高(只需要能踩过大弹丸就行)，故轮子半径可以不需要11cm那么大(11cm是2023赛季的数据)，可以不用为了设计大轮子而导致云台设计出现很大的问题。</p><h2 id="铝框防护设计"><a href="#铝框防护设计" class="headerlink" title="铝框防护设计"></a>铝框防护设计</h2><img src="./3.jpg" width = "300" height = "400" alt="图片名称" align=center /><p>外层铝框并不是必要的，但它可以有效防止腿被卡住或者对腿造成很大损伤，故最好加上。其刚度是最为重要的特性，因为需要经常经历碰撞，设计时需要特别注意。</p><h2 id="腿设计"><a href="#腿设计" class="headerlink" title="腿设计"></a>腿设计</h2><img src="./4.jpg" width = "300" height = "200" alt="图片名称" align=center /><img src="./5.jpg" width = "300" height = "200" alt="图片名称" align=center /><p>目前算法对腿的长度以及各腿比例要求并不高，但是2023赛季有一个问题，就是装上铝框之后，右侧关节与左侧关节连接处安装方式不同导致摩擦力大小不一样，这将会导致起跳时往一边倾斜。</p><p>电机包装得太过严密，导致电机散热很成问题，这将使电机很容易进入过热保护状态。</p><h2 id="腿上下限位设计"><a href="#腿上下限位设计" class="headerlink" title="腿上下限位设计"></a>腿上下限位设计</h2><img src="./6.jpg" width = "300" height = "200" alt="图片名称" align=center /><p>由于在进行运动学解算时，不只有一个解，为将腿保持在一定范围内，需要限制两侧小腿的角度，防止出现异形腿的情况无法恢复。上下限位共同决定了关节的运动范围，同时上限位作为关节电机初始化的位置，必须保证左右两个小腿在机器人倒下时能够自然收到两个限位处。下限位则决定了起跳或者站立的最大高度。</p><h2 id="倾倒导轮设计"><a href="#倾倒导轮设计" class="headerlink" title="倾倒导轮设计"></a>倾倒导轮设计</h2><img src="./7.jpg" width = "300" height = "200" alt="图片名称" align=center /><img src="./8.jpg" width = "300" height = "200" alt="图片名称" align=center /><p>倾倒角度指的是机器人不受力时自然倾倒时，车身与水平的夹角(如图)，倾角较小时起身功率将会降低很多，但可能会导致上坡时导轮磕到坡，故需要设计到一个合适的角度(2023赛季为18度)。上交通过减小倾角，同时在上坡时让机器人抬腿抬高，这是一个不错的优化思路，可以参考一下。</p><p>该导轮设计时最好不要在装甲板外面，因为如果露出在装甲板外面，将会导致机器人变长，这样下落凤坡时若速度不够，则很容易磕到导轮翻车。(这一点同时也要求车尽量做短一些)。</p><p>该导轮位置也是磕碰重灾区，需要保证刚度。</p><h2 id="NUC位置设计"><a href="#NUC位置设计" class="headerlink" title="NUC位置设计"></a>NUC位置设计</h2><img src="./9.jpg" width = "300" height = "200" alt="图片名称" align=center /><p>目前NUC设计在云台与底盘连接处，这会导致NUC散热困难，散出的热量会加剧关节电机的发热。</p><h2 id="Yaw轴固定设计"><a href="#Yaw轴固定设计" class="headerlink" title="Yaw轴固定设计"></a>Yaw轴固定设计</h2><img src="./11.jpg" width = "300" height = "200" alt="图片名称" align=center /><p>当前(2023赛季)固定方式十分冗余，使机器人增重明显。</p><h2 id="IMU位置设计"><a href="#IMU位置设计" class="headerlink" title="IMU位置设计"></a>IMU位置设计</h2><img src="./10.jpg" width = "300" height = "200" alt="图片名称" align=center /><p>IMU需要放置在如图的位置，但图中由于设计问题，若需要更换IMU则需要将底下的整块板子拆掉，十分麻烦，故下一版车需要特别考虑这个问题。</p><h2 id="其它细节问题"><a href="#其它细节问题" class="headerlink" title="其它细节问题"></a>其它细节问题</h2><ol><li><p>在电路完整布完线之后，需要检查一下重心位置，尽量把两边调整到对称位置。</p></li><li><p>减一下重(23赛季23kg左右)，否则起身功率很高以及起跳困难。</p></li><li><p>设计完成之后记得和电路讨论一下布线，尽量让布线阳间一点。</p></li></ol><h2 id="修改日志"><a href="#修改日志" class="headerlink" title="修改日志"></a>修改日志</h2><ul><li><p>2023.8.19 首次记录</p></li><li><p>2023.8.20 增加Yaw轴固定设计以及IMU位置设计描述</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;轮腿平衡步兵总结-机械设计篇&quot;&gt;&lt;a href=&quot;#轮腿平衡步兵总结-机械设计篇&quot; class=&quot;headerlink&quot; title=&quot;轮腿平衡步兵总结 - 机械设计篇&quot;&gt;&lt;/a&gt;轮腿平衡步兵总结 - 机械设计篇&lt;/h1&gt;&lt;h2 id=&quot;轮子设计&quot;&gt;&lt;a href</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>卡尔曼滤波系列教程 - 从一阶低通滤波到卡尔曼滤波</title>
    <link href="https://xianmengxi.github.io/2023/10/15/qia-er-man-lu-bo-xi-lie-jiao-cheng-cong-yi-jie-di-tong-lu-bo-dao-qia-er-man-lu-bo/"/>
    <id>https://xianmengxi.github.io/2023/10/15/qia-er-man-lu-bo-xi-lie-jiao-cheng-cong-yi-jie-di-tong-lu-bo-dao-qia-er-man-lu-bo/</id>
    <published>2023-10-15T02:00:00.000Z</published>
    <updated>2023-11-21T12:35:17.130Z</updated>
    
    <content type="html"><![CDATA[<h1 id="卡尔曼滤波系列教程-从一阶低通滤波到卡尔曼滤波"><a href="#卡尔曼滤波系列教程-从一阶低通滤波到卡尔曼滤波" class="headerlink" title="卡尔曼滤波系列教程 - 从一阶低通滤波到卡尔曼滤波"></a>卡尔曼滤波系列教程 - 从一阶低通滤波到卡尔曼滤波</h1><h2 id="一阶低通滤波"><a href="#一阶低通滤波" class="headerlink" title="一阶低通滤波"></a>一阶低通滤波</h2><p>一阶低通滤波的公式如下：<br>$$<br>    y_k &#x3D; (1 - a) y_{k - 1} + a x_k<br>$$</p><p>该<a href="https://blog.csdn.net/weixin_42887190/article/details/125749509">链接</a>中的博客详细介绍了一阶低通滤波的原理以及公式推导（需要一些拉式变换的前置知识），重点理解该一阶低通滤波的截止频率计算，能够辅助进行微分滤波以及PID输出滤波的系数计算。</p><p>我们将该公式转化为：</p><p>$$<br>    y_k &#x3D; (1 - a) y_{k - 1} + a x_k &#x3D; y_{k-1} + a (x_k - y_{k - 1})<br>$$</p><p>如果你熟悉卡尔曼滤波的话，你会发现这与卡尔曼滤波中黄金五式中的最后一式有异曲同工之妙。</p><p>$$<br>    \hat{x_k} &#x3D; \hat{x_k^-} + K_k(z_k - H\hat{x_k^-})<br>$$</p><p>也即一阶低通滤波是卡尔曼增益为a，且卡尔曼增益不变，测量矩阵H为单位阵的特殊一阶卡尔曼滤波。这就是为什么说，若卡尔曼滤波收敛（卡尔曼滤波收敛意味着卡尔曼增益不变），最终卡尔曼滤波效果将等效于低通滤波。</p><p>是不是很神奇呢&#x3D;￣ω￣&#x3D;，即便是听起来很“高大上”的卡尔曼滤波，本质上也与低通滤波无异(￣y▽,￣)╭ 。</p><h2 id="观测器"><a href="#观测器" class="headerlink" title="观测器"></a>观测器</h2><p>我们学校的《自动控制原理（二）》课程将会讲述关于状态空间的现代控制理论，里面提到的龙贝格观测器的形式如下：</p><p>$$<br>    \dot{\hat{x}} &#x3D; A\hat{x} + Bu + L(y - C\hat{x})<br>$$</p><p>利用前向欧拉方法将方程离散化有：</p><p>$$<br>    \frac{\hat{x_{k+1}} - \hat{x_{k}}}{\Delta t} &#x3D; A \hat{x_{k}} + Bu_k + L(y_k - C\hat{x_{k}})<br>$$</p><p>化简有：</p><p>$$<br>    \hat{x_{k+1}} &#x3D; (A\Delta t + I)\hat{x_{k}} + B\Delta t u_k + L\Delta t(y_k - C\hat{x_{k}})<br>$$</p><p>你会发现该龙贝格观测器中的$L\Delta t$矩阵相当于卡尔曼滤波中的卡尔曼增益K，但$L\Delta t$矩阵是一个常数矩阵，故龙贝格观测器也是一个简化版的卡尔曼滤波，卡尔曼滤波本质上也是一个观测器。这里推荐<a href="https://zhuanlan.zhihu.com/p/338269917">从全状态观测器到卡尔曼滤波器</a>该系列教程。</p><p>如果你想学习一下现代控制理论内容，推荐该教程<a href="https://www.bilibili.com/video/BV1yx411u7iX/?spm_id_from=333.999.0.0">Advanced控制理论</a></p><p>知识瞬间串联起来啦😺</p><h2 id="卡尔曼滤波"><a href="#卡尔曼滤波" class="headerlink" title="卡尔曼滤波"></a>卡尔曼滤波</h2><p>推荐先看<a href="https://www.bilibili.com/video/BV1ez4y1X7eR/?spm_id_from=333.337.search-card.all.click&vd_source=c9ad8e271fb7bd801090950dd31af8e5">卡尔曼滤波系列</a></p><p>卡尔曼滤波黄金五式如下：</p><p>预测过程：<br>$$<br>    \hat{x_k^-} &#x3D; A \hat{x_{k-1}^-} + B_k u_k<br>$$</p><p>$$<br>    P_k^- &#x3D; A_k P_{k-1} A_k^T + Q<br>$$</p><p>更新过程：<br>$$<br>    K_k &#x3D; \frac{P_k^- H_k^T}{H_k P_k^- H_k^T + R}<br>$$</p><p>$$<br>    P_k &#x3D; (I - K_k H_k) P_k^-<br>$$</p><p>$$<br>    \hat{x_k} &#x3D; \hat{x_k^-} + K_k(z_k - H\hat{x_k^-})<br>$$</p><p>首先来看预测过程：</p><p>$$<br>    \hat{x_k^-} &#x3D; A \hat{x_{k-1}^-} + B_k u_k<br>$$</p><p>$$<br>    P_k^- &#x3D; A_k P_{k-1} A_k^T + Q<br>$$</p><p>何谓预测呢？也即通过上一个时刻的状态通过<em><strong>预先假设的模型</strong></em>来计算下一个时刻的状态，然后通过更新过程检验模型的正确性。所以，该预先假设的模型决定了卡尔曼滤波的上限，越准确的模型卡尔曼滤波上限越高。</p><p>$A_k$矩阵为状态转移矩阵，即表达了如何从$\hat{x_{k-1}^-}$到$\hat{x_k^-}$的转化。</p><p>$u_k$为控制量，怎么去理解这个控制量呢？也即我们在从$\hat{x_{k-1}^-}$到$\hat{x_k^-}$的转化时，能够对状态变量产生影响，但本身不在状态变量里面的量。例如若选择位移与速度为状态变量，若我们的机器人上有加速度计，则可以将加速度作为$u_k$，这一步目的是使预测过程更加准确。</p><p>$P_{k-1}$为$\hat{x_{k-1}^-}$的协方差矩阵，那么进行$A_k \hat{x_{k-1}^-}$操作之后，方差自然变成了$A_k P_{k-1} A_k^T$。</p><p>也就是说$P_k^-$的计算之中，<em><strong>没有考虑</strong></em>$u_k$的噪声，也就是说，在设计过程中，$u_k$需要是足够准确的，可以认为是没有噪声的；或者，$u_k$的噪声需要计入Q矩阵中，作为预测过程的不确定性。</p><p>关于Q矩阵，它的定义是预测过程的不确定性。当Q越大，那么意味着你对你自己的猜测越没有把握；当Q为0矩阵时，你完全相信你的预测，更新过程将不起作用，最终状态由预测决定；当Q为系数无穷大矩阵时，你完全不相信你的预测，故预测过程将不起作用，最终状态由更新过程决定。Q矩阵需要程序调试者预先设定，<em><strong>注意Q矩阵不能默认为对角阵</strong></em>，应根据各个状态变量之间的关联来进行设定。你永远不知道你的预测有多不准确，故这个参数是需要在每个应用场景中实践去调参得到的。</p><p>再看更新过程：<br>$$<br>    K_k &#x3D; \frac{P_k^- H_k^T}{H_k P_k^- H_k^T + R}<br>$$</p><p>$$<br>    P_k &#x3D; (I - K_k H_k) P_k^-<br>$$</p><p>$$<br>    \hat{x_k} &#x3D; \hat{x_k^-} + K_k(z_k - H\hat{x_k^-})<br>$$</p><p>看一个不严谨的推导，若$K_k &#x3D; 0$，则$\hat{x_k} &#x3D; \hat{x_k^-}$，这意味着结果完全由预测决定，测量量$z_k$将不起作用；若$R &#x3D; 0$,则$K_k &#x3D; \frac{1}{H_k}$，$\hat{x_k} &#x3D; \frac{z_k}{H_k}$，此时结果完全由测量过程（也即更新过程）决定。</p><p>根据$K_k$的定义，当R越大，$K_k$越小，$\hat{x_k}$就越不相信更新过程。</p><p>$z_k$根据定义应该为传感器直接输出的变量，因为<em><strong>传感器直接测量的值和我们设定的状态变量不一定相同</strong></em>，故需要使用H矩阵对$\hat{x_k^-}$转化为传感器测量的量。</p><p>R矩阵的定义为$z_k$的协方差，该值和Q不同，它应该是<em><strong>完全确定的</strong></em>。它反映了传感器的精度，可以通过查看传感器的参数手册，或者通过数理统计的方法来计算得到。</p><p>卡尔曼滤波实际应用包括卡尔曼滤波设计以及卡尔曼滤波调参，以下一一分析。</p><h2 id="卡尔曼滤波设计"><a href="#卡尔曼滤波设计" class="headerlink" title="卡尔曼滤波设计"></a>卡尔曼滤波设计</h2><p>根据该卡尔曼滤波的黄金五式，设计卡尔曼滤波核心在于设计$\hat{x_k^-} &#x3D; A \hat{x_{k-1}^-} + B_k u_k$以及H矩阵。</p><p>$\hat{x_k^-} &#x3D; A \hat{x_{k-1}^-} + B_k u_k$可以根据典型的假设模型，例如恒速度模型（CV运动模型），恒加速度模型（CA运动模型）等进行假设，也可以根据动力学方程等得到。</p><p>H矩阵则是根据状态变量到测量变量的转化得到，注意构建起这两者的线性联系。</p><h2 id="卡尔曼滤波调参"><a href="#卡尔曼滤波调参" class="headerlink" title="卡尔曼滤波调参"></a>卡尔曼滤波调参</h2><h3 id="初值设定"><a href="#初值设定" class="headerlink" title="初值设定"></a>初值设定</h3><p>卡尔曼滤波需要给定$x_{0}$以及$P_0$作为初值，一般来说$x_{0}$会以传感器测量的值通过一定运算得到的值作为初值，而$P_0$一般设置为单位阵让其自动迭代收敛即可（也可以根据你对状态变量的理解提前设定好该矩阵的值）。</p><h3 id="矩阵调参"><a href="#矩阵调参" class="headerlink" title="矩阵调参"></a>矩阵调参</h3><p>需要调整的参数包括Q矩阵以及R矩阵。</p><p>R矩阵的调整上面已经说明。</p><p>Q矩阵的调整则首先需要确定预测不确定性的来源，例如CV运动模型中带有匀速假设，故预测不确定性来源在于物体运动的加速度，通过加速度将各个状态变量的状态估计协方差联系起来（具体可以看CV运动模型的介绍）。</p><p>调参过程需要不断调整Q矩阵来达到满意的效果。</p><p>当我们抛去公式推导来看卡尔曼滤波后，是不是觉得卡尔曼滤波瞬间没有那么难了呢&lt;(￣︶￣)↗[GO!]</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;卡尔曼滤波系列教程-从一阶低通滤波到卡尔曼滤波&quot;&gt;&lt;a href=&quot;#卡尔曼滤波系列教程-从一阶低通滤波到卡尔曼滤波&quot; class=&quot;headerlink&quot; title=&quot;卡尔曼滤波系列教程 - 从一阶低通滤波到卡尔曼滤波&quot;&gt;&lt;/a&gt;卡尔曼滤波系列教程 - 从一阶</summary>
      
    
    
    
    <category term="RoboMaster" scheme="https://xianmengxi.github.io/categories/RoboMaster/"/>
    
    
    <category term="RoboMaster" scheme="https://xianmengxi.github.io/tags/RoboMaster/"/>
    
    <category term="电控组" scheme="https://xianmengxi.github.io/tags/%E7%94%B5%E6%8E%A7%E7%BB%84/"/>
    
    <category term="卡尔曼滤波" scheme="https://xianmengxi.github.io/tags/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/"/>
    
    <category term="状态估计" scheme="https://xianmengxi.github.io/tags/%E7%8A%B6%E6%80%81%E4%BC%B0%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>轮毂电机参数辨识</title>
    <link href="https://xianmengxi.github.io/2023/10/15/lun-gu-dian-ji-can-shu-bian-shi/"/>
    <id>https://xianmengxi.github.io/2023/10/15/lun-gu-dian-ji-can-shu-bian-shi/</id>
    <published>2023-10-15T02:00:00.000Z</published>
    <updated>2023-11-21T12:36:18.074Z</updated>
    
    <content type="html"><![CDATA[<h1 id="轮毂电机参数辨识"><a href="#轮毂电机参数辨识" class="headerlink" title="轮毂电机参数辨识"></a>轮毂电机参数辨识</h1><h2 id="模型设计"><a href="#模型设计" class="headerlink" title="模型设计"></a>模型设计</h2><p>轮毂电机型号为MF9025,类型为直流无刷电机(BLDC),为了得到轮毂电机附带轮子包胶的转动惯量以及阻尼系数，构建对地面负载转矩的估算算法，故需要对轮子进行参数辨识。</p><p>电机运动方程为</p><p>$$<br>    T_l - T_e &#x3D; J \frac{d w_c}{dt} + B w_c<br>$$</p><p>其中$T_l$为电机输出转矩,$T_e$为负载转矩,J为轮子转动惯量,$w_c$为轮子运动角速度，B为运动阻尼系数。</p><p>将轮子腾空处理，认为$T_e &#x3D; 0$</p><p>对方程两端进行拉普拉斯变换转换为频域有</p><p>$$<br>    T_l(s) &#x3D; JsW_c(s) + BW_c(s)<br>$$</p><p>即<br>$$<br>    \frac{W_c(s)}{T_l(s)} &#x3D; \frac{1}{Js + B}<br>$$</p><p>使用以下代码记录每一次的反馈力矩以及反馈角速度，并使用Ozone(或者Jscope)导出对应的数据(w,T),注意发送力矩时，由于是空载，不要输入过大的力矩，否则会使转速达到最大导致饱和。</p><pre class=" language-c"><code class="language-c">    t_ <span class="token operator">=</span> <span class="token function">GetDeltaTtoNow</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>last_cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>    wheels_torque<span class="token punctuation">[</span>identify_id<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0.25f</span> <span class="token operator">*</span> <span class="token function">arm_sin_f32</span><span class="token punctuation">(</span>t_<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//更新w,T信息反馈</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        w<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        T<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> T<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    w<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> Wheels_Motor<span class="token punctuation">.</span>decoded_msgs<span class="token punctuation">[</span>identify_id<span class="token punctuation">]</span><span class="token punctuation">.</span>rotate_speed<span class="token punctuation">;</span>    T<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> Wheels_Motor<span class="token punctuation">.</span>decoded_msgs<span class="token punctuation">[</span>identify_id<span class="token punctuation">]</span><span class="token punctuation">.</span>current <span class="token operator">*</span> MF9025_TORQUE_CURRENT_RATIO<span class="token punctuation">;</span>    <span class="token function">WheelCurrentPack</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>wheels<span class="token punctuation">,</span> wheels_torque<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">WheelCanSend</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>wheels<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Ozone导出来的数据是以分号分隔的数据，故需要对数据进行分割，可使用数据栏中的分列功能实现数据分离。</p><p><img src="/2023/10/15/lun-gu-dian-ji-can-shu-bian-shi/2023-03-08-21-01-49.png"></p><p>最终生成的数据如下图所示:</p><p><img src="/2023/10/15/lun-gu-dian-ji-can-shu-bian-shi/2023-03-08-21-02-18.png"></p><p>打开Matlab，利用以下语句读取csv文件</p><pre class=" language-matlab"><code class="language-matlab">    <span class="token function">csvread</span><span class="token punctuation">(</span><span class="token string">'1.csv'</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">% 1,0 表示从第二行第一列开始读</span></code></pre><p>打开System Identification工具箱,导入输入变量与输出变量数据</p><p><img src="/2023/10/15/lun-gu-dian-ji-can-shu-bian-shi/2023-03-08-21-06-57.png"></p><p>导入后点击Time plot可以看到导入的数据</p><p><img src="/2023/10/15/lun-gu-dian-ji-can-shu-bian-shi/2023-03-08-21-08-07.png"></p><p>在operation - select range 中，将数据集划分为训练集和测试集(图中绿色为训练集，红色为测试集)</p><p><img src="/2023/10/15/lun-gu-dian-ji-can-shu-bian-shi/2023-03-08-21-11-06.png"></p><p>仅将测试集点亮，点击estimate，选择传递函数进行参数辨识，由需要辨识的传递函数的形式，将极点数设置为1，零点数设置为0.</p><p><img src="/2023/10/15/lun-gu-dian-ji-can-shu-bian-shi/2023-03-08-21-12-50.png"></p><p>最终拟合度为88.56%,一般大于85%认为拟合有效<br><img src="/2023/10/15/lun-gu-dian-ji-can-shu-bian-shi/2023-03-08-21-14-36.png"></p><p>将测试集拉入validation Data中，点击Model output可以看到测试集和拟合模型的比较关系。</p><p><img src="/2023/10/15/lun-gu-dian-ji-can-shu-bian-shi/2023-03-08-21-16-02.png"></p><p>最终传递函数为</p><p>$$<br>    \frac{W_c(s)}{T_l(s)} &#x3D; \frac{1}{\frac{1}{2750}s + \frac{10.67}{2750}}<br>$$</p><p><img src="/2023/10/15/lun-gu-dian-ji-can-shu-bian-shi/2023-03-08-21-17-41.png"></p><p>故<br>$$<br>    J &#x3D; \frac{1}{2750} &#x3D; 0.0003636<br>$$</p><p>$$<br>    B &#x3D; \frac{10.67}{2750} &#x3D; 0.00388<br>$$</p><h2 id="负载转矩实时估算"><a href="#负载转矩实时估算" class="headerlink" title="负载转矩实时估算"></a>负载转矩实时估算</h2><p>由<br>$$<br>    T_l - T_e &#x3D; J \frac{d w_c}{dt} + B w_c<br>$$</p><p>可得</p><p>$$<br>    T_e &#x3D; T_l - J \frac{d w_c}{dt} - B w_c<br>$$</p><p>当估计负载转矩小于一定阈值时，认为轮子腾空或者打滑，此时应让轮子停转。</p><p>$$<br>    T_e &lt; \epsilon<br>$$</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;轮毂电机参数辨识&quot;&gt;&lt;a href=&quot;#轮毂电机参数辨识&quot; class=&quot;headerlink&quot; title=&quot;轮毂电机参数辨识&quot;&gt;&lt;/a&gt;轮毂电机参数辨识&lt;/h1&gt;&lt;h2 id=&quot;模型设计&quot;&gt;&lt;a href=&quot;#模型设计&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="RoboMaster" scheme="https://xianmengxi.github.io/categories/RoboMaster/"/>
    
    
    <category term="RoboMaster" scheme="https://xianmengxi.github.io/tags/RoboMaster/"/>
    
    <category term="电控组" scheme="https://xianmengxi.github.io/tags/%E7%94%B5%E6%8E%A7%E7%BB%84/"/>
    
    <category term="状态估计" scheme="https://xianmengxi.github.io/tags/%E7%8A%B6%E6%80%81%E4%BC%B0%E8%AE%A1/"/>
    
    <category term="参数辨识" scheme="https://xianmengxi.github.io/tags/%E5%8F%82%E6%95%B0%E8%BE%A8%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>有手就能学会的Github Desktop教程</title>
    <link href="https://xianmengxi.github.io/2023/09/20/you-shou-jiu-neng-xue-hui-de-github-desktop-jiao-cheng/"/>
    <id>https://xianmengxi.github.io/2023/09/20/you-shou-jiu-neng-xue-hui-de-github-desktop-jiao-cheng/</id>
    <published>2023-09-20T02:00:00.000Z</published>
    <updated>2023-11-21T12:37:53.141Z</updated>
    
    <content type="html"><![CDATA[<h1 id="有手就能学会的Github-Desktop教程"><a href="#有手就能学会的Github-Desktop教程" class="headerlink" title="有手就能学会的Github Desktop教程"></a>有手就能学会的Github Desktop教程</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很多git使用教程对新手不友好，因为都使用了git bash作为命令行工具进行操作，这对于不是算法组的同学来说会非常难以接受(其实对于算法组的同学来说也很难接受)，那么有没有一个图形化界面工具来帮助我们快速实现克隆仓库，同步仓库以及修改仓库等操作呢？很多人也许会回答：有，那就是Gitkraken，但最新版本的Gitkraken有一个很麻烦的地方就是私有仓库需要付费。作为一个资深白嫖党自然不可能付费，故此处推荐Github Desktop作为其替代工具。</p><h2 id="克隆仓库操作"><a href="#克隆仓库操作" class="headerlink" title="克隆仓库操作"></a>克隆仓库操作</h2><p>此处假设你已经正确安装好了Github Desktop并且已经登陆好自己的账号。(这么简单的东西都不会的话我笑你一坤年)</p><p>如下图，选择File - Clone repository，即可进行克隆仓库操作，该操作即为把github上的代码拷贝到本地。与在github上网站的Download Zip下载不同的是，Clone操作会附带一个.git文件，里面会包含一些仓库的修改以及上传情况。</p><p><img src="/2023/09/20/you-shou-jiu-neng-xue-hui-de-github-desktop-jiao-cheng/2023-08-30-10-46-21.png"></p><p><img src="/2023/09/20/you-shou-jiu-neng-xue-hui-de-github-desktop-jiao-cheng/2023-08-30-10-48-23.png"></p><p>此处我以HUSTLYRM&#x2F;Documentation为例子，选择好自己的下载位置之后，点击“Clone”。</p><p><img src="/2023/09/20/you-shou-jiu-neng-xue-hui-de-github-desktop-jiao-cheng/2023-08-30-10-55-39.png"></p><p>等待下载远程仓库结束之后，将会出现以下界面，这说明克隆仓库到本地成功了。</p><p><img src="/2023/09/20/you-shou-jiu-neng-xue-hui-de-github-desktop-jiao-cheng/2023-08-30-10-58-56.png"></p><h2 id="修改仓库同步到远程仓库"><a href="#修改仓库同步到远程仓库" class="headerlink" title="修改仓库同步到远程仓库"></a>修改仓库同步到远程仓库</h2><p>首先你需要找到你刚才克隆仓库所在的文件夹，此例子为“E：\code\Documentation”。</p><p><img src="/2023/09/20/you-shou-jiu-neng-xue-hui-de-github-desktop-jiao-cheng/2023-08-30-11-00-56.png"></p><p>你在此文件夹加入的文件，修改的文件，删除的文件，都可以在Github Desktop中看到，例如我修改了README.md之后，</p><p><img src="/2023/09/20/you-shou-jiu-neng-xue-hui-de-github-desktop-jiao-cheng/2023-08-30-11-03-14.png"></p><p>在左下角的输入框中输入你此处修改的理由以及内容之后，点击“commit to master”即可同意本次修改(注意这里只是本地认可了这个修改，并没有同步到远程仓库)。</p><p>若不认可这个修改怎么办，可以右击那个修改然后点击Discard changes，然后该README.md文件的内容将会自动恢复为原来的内容，即这次修改无效。</p><p><img src="/2023/09/20/you-shou-jiu-neng-xue-hui-de-github-desktop-jiao-cheng/2023-08-30-11-07-28.png"></p><p>修改结束之后，若你想同步到Github上，则可以点击Push origin</p><p><img src="/2023/09/20/you-shou-jiu-neng-xue-hui-de-github-desktop-jiao-cheng/2023-08-30-11-10-14.png"></p><p>此时，再登陆Github，就可以看到修改啦</p><p><img src="/2023/09/20/you-shou-jiu-neng-xue-hui-de-github-desktop-jiao-cheng/2023-08-30-11-11-19.png"></p><h2 id="远程仓库同步到本地仓库"><a href="#远程仓库同步到本地仓库" class="headerlink" title="远程仓库同步到本地仓库"></a>远程仓库同步到本地仓库</h2><p>假设有一个仓库别人已经修改过了，并且已经将修改的内容上传到Github上了，但你现在本地的代码仍然是旧的，你想将你本地的代码同步到Github上最新的代码，那么可以点击Fetch origin按钮。</p><p><img src="/2023/09/20/you-shou-jiu-neng-xue-hui-de-github-desktop-jiao-cheng/2023-08-30-11-16-28.png"></p><h2 id="创建仓库并且上传内容"><a href="#创建仓库并且上传内容" class="headerlink" title="创建仓库并且上传内容"></a>创建仓库并且上传内容</h2><p>在Github上点击New创建完仓库之后，再按以上克隆仓库操作进行即可。</p><p><img src="/2023/09/20/you-shou-jiu-neng-xue-hui-de-github-desktop-jiao-cheng/2023-08-30-11-19-04.png"></p><h2 id="看修改记录"><a href="#看修改记录" class="headerlink" title="看修改记录"></a>看修改记录</h2><p>在History一栏中，可以看到谁修改了什么，即增删了那些文件，文件内增加了哪几行，删除了哪几行，都一目了然。(谁是演员一看便知)</p><p><img src="/2023/09/20/you-shou-jiu-neng-xue-hui-de-github-desktop-jiao-cheng/2023-08-30-11-21-46.png"></p><h2 id="版本回溯"><a href="#版本回溯" class="headerlink" title="版本回溯"></a>版本回溯</h2><p>在想要回溯的位置右击，点击Checkout commit，可以将这之后的修改全部抹除掉。又回到最初的起点~</p><p><img src="/2023/09/20/you-shou-jiu-neng-xue-hui-de-github-desktop-jiao-cheng/2023-08-30-11-24-52.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;有手就能学会的Github-Desktop教程&quot;&gt;&lt;a href=&quot;#有手就能学会的Github-Desktop教程&quot; class=&quot;headerlink&quot; title=&quot;有手就能学会的Github Desktop教程&quot;&gt;&lt;/a&gt;有手就能学会的Github Des</summary>
      
    
    
    
    <category term="Github" scheme="https://xianmengxi.github.io/categories/Github/"/>
    
    
    <category term="Github" scheme="https://xianmengxi.github.io/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>卡尔曼滤波系列教程 - 序</title>
    <link href="https://xianmengxi.github.io/2023/09/10/qia-er-man-lu-bo-xi-lie-xu/"/>
    <id>https://xianmengxi.github.io/2023/09/10/qia-er-man-lu-bo-xi-lie-xu/</id>
    <published>2023-09-10T02:00:00.000Z</published>
    <updated>2023-11-21T12:35:22.052Z</updated>
    
    <content type="html"><![CDATA[<h1 id="卡尔曼滤波系列教程-序"><a href="#卡尔曼滤波系列教程-序" class="headerlink" title="卡尔曼滤波系列教程 - 序"></a>卡尔曼滤波系列教程 - 序</h1><p>我从大一寒假开始接触卡尔曼滤波，从零开始学习时最怕的就是一堆不明所以的公式，对数学不好的人来说，公式推导就是一场噩梦≡(▔﹏▔)≡，所以我很能理解大家在刚开始深入了解卡尔曼滤波时会感到云里雾里。大二时我曾被一个错误的卡尔曼滤波器设计误导过并走了不少的弯路，所以我希望你们能够避免走我走过的弯路(;´༎ຶД༎ຶ&#96;)。随着接触卡尔曼滤波越来越多，我慢慢地感受到了卡尔曼滤波的魅力，并且学习越深入，越能感受到其设计之精彩(o゜▽゜)o☆。</p><p>我想去写这一系列教程的原因是，当前团队里对卡尔曼滤波的功能有基本了解的人都屈指可数，甚至即便是打过一年比赛的人，都没几个从零开始设计过一个卡尔曼滤波器并将其应用到实际中。而卡尔曼滤波作为嵌软组和算法组的核心必修课，其重要地位不言而喻。我希望这一系列教程可以在未来的至少三到五年，都能不落俗套地帮助未来的狼牙er更快地理解卡尔曼滤波，参透其中的设计意图§(<em>￣▽￣</em>)§。</p><p>以下是该系列教程的基本内容介绍：</p><ul><li><p>《序》：介绍整个系列基本内容</p></li><li><p>《从一阶低通滤波到卡尔曼滤波》：不讨论卡尔曼滤波的公式推导，仅讨论如何从直观上理解黄金五式中各个参数的含义。</p></li><li><p>《卡尔曼滤波功能分析》：将分功能阐述卡尔曼滤波如何应用到实际中，示例中将会使用Matlab进行低阶卡尔曼滤波的演示，课后习题将要求算法组的同学使用Eigen，嵌软组的同学使用Arm Math库复刻该卡尔曼滤波(甚至需要升阶)。</p><ul><li><p>《卡尔曼滤波器功能之滤波器》</p></li><li><p>《卡尔曼滤波器功能之微分器》：以CV运动模型为例</p></li><li><p>《卡尔曼滤波器功能之积分器》：以轮速里程计为例</p></li><li><p>《卡尔曼滤波器功能之数据融合》：以加速度计与轮速里程计数据融合为例</p></li><li><p>《卡尔曼滤波器功能之异常检测》：卡方检验</p></li><li><p>《卡尔曼滤波器功能之数据拟合》：本质上是最小二乘法</p></li></ul></li><li><p>《卡尔曼滤波变种》：主要如何从卡尔曼滤波过渡到扩展卡尔曼滤波，阐述其过渡的意义。</p><ul><li><p>《扩展卡尔曼滤波EKF》：将以CV运动模型中的球面模型测量模型为例</p></li><li><p>UKF(待补充)</p></li><li><p>ESKF(待补充)</p></li></ul></li><li><p>《卡尔曼滤波终极应用》</p><ul><li><p>《IMU滤波算法》</p></li><li><p>《整车估计算法》</p></li></ul></li></ul><p>哼༼ つ ◕_◕ ༽つ，你爱看不看(ಥ _ ಥ)。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;卡尔曼滤波系列教程-序&quot;&gt;&lt;a href=&quot;#卡尔曼滤波系列教程-序&quot; class=&quot;headerlink&quot; title=&quot;卡尔曼滤波系列教程 - 序&quot;&gt;&lt;/a&gt;卡尔曼滤波系列教程 - 序&lt;/h1&gt;&lt;p&gt;我从大一寒假开始接触卡尔曼滤波，从零开始学习时最怕的就是一堆</summary>
      
    
    
    
    <category term="RoboMaster" scheme="https://xianmengxi.github.io/categories/RoboMaster/"/>
    
    
    <category term="RoboMaster" scheme="https://xianmengxi.github.io/tags/RoboMaster/"/>
    
    <category term="电控组" scheme="https://xianmengxi.github.io/tags/%E7%94%B5%E6%8E%A7%E7%BB%84/"/>
    
    <category term="卡尔曼滤波" scheme="https://xianmengxi.github.io/tags/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/"/>
    
    <category term="状态估计" scheme="https://xianmengxi.github.io/tags/%E7%8A%B6%E6%80%81%E4%BC%B0%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>轮腿平衡步兵总结 - 完结篇</title>
    <link href="https://xianmengxi.github.io/2023/08/26/lun-tui-ping-heng-bu-bing-zong-jie-wan-jie-pian/"/>
    <id>https://xianmengxi.github.io/2023/08/26/lun-tui-ping-heng-bu-bing-zong-jie-wan-jie-pian/</id>
    <published>2023-08-26T02:00:00.000Z</published>
    <updated>2023-11-21T12:22:16.008Z</updated>
    
    <content type="html"><![CDATA[<h1 id="轮腿平衡步兵总结-完结篇"><a href="#轮腿平衡步兵总结-完结篇" class="headerlink" title="轮腿平衡步兵总结 - 完结篇"></a>轮腿平衡步兵总结 - 完结篇</h1><p>2023 年对轮腿平衡步兵来说是不平凡的一年，在这一年里，我第一次作为嵌软组成员参加 RM 比赛，第一次让轮腿平衡步兵具备上场能力。</p><p>联盟赛，由于轮腿平衡步兵没能及时做出来，队长安排我去帮忙调普步，我拒绝了，甚至还和队长闹掰了，只是因为那能在平衡步兵做好之后马上调完的执念。</p><p>分区赛，由于平衡步兵过不了大弹丸的问题导致未能上场，我作为操作手体验了精神上的多重折磨，让我不堪重负。</p><p>复活赛中，我坐在观众席见证了它第一次得到 MVP，却在之后被连扳两局淘汰回家。</p><p>回顾自己的 23 赛季，有太多苦涩的回忆。我经历了无数次失败，无数次对自己能力的质疑，无数次想过放弃，无数次跌倒后爬起来，但我必须回应队友们的期待。就像这平衡步兵一样，我已经忘记了它到底摔过了几次，但摔过之后它依旧可以站起来，并且越来越好。</p><p>打 RM 让我最印象深刻的一句话便是细节决定成败，赛场很残酷，不要抱着侥幸的心理上场，你要对自己做的功能哪里可能会出问题有足够的了解，并且避免把问题带到赛场上。</p><p>你要想着如何把功能优化到极致，而不是墨守成规，不思进取。没有创造力在 RM 是无法生存下去的。</p><p>当你站在赛场上，聆听着场间三分钟音乐的时候，你也许就会感叹，这就是热爱吧，你会觉得你做的每一分努力都很值得。</p><p><a href="https://www.bilibili.com/video/BV1jF411B7sw/?spm_id_from=333.337.search-card.all.click">纵使三度迎来日落，太阳依旧照常升起。</a></p><p>这些总结应该是我留给狼牙战队最后的礼物了吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;轮腿平衡步兵总结-完结篇&quot;&gt;&lt;a href=&quot;#轮腿平衡步兵总结-完结篇&quot; class=&quot;headerlink&quot; title=&quot;轮腿平衡步兵总结 - 完结篇&quot;&gt;&lt;/a&gt;轮腿平衡步兵总结 - 完结篇&lt;/h1&gt;&lt;p&gt;2023 年对轮腿平衡步兵来说是不平凡的一年，在这一</summary>
      
    
    
    
    <category term="RoboMaster" scheme="https://xianmengxi.github.io/categories/RoboMaster/"/>
    
    
    <category term="RoboMaster" scheme="https://xianmengxi.github.io/tags/RoboMaster/"/>
    
    <category term="电控组" scheme="https://xianmengxi.github.io/tags/%E7%94%B5%E6%8E%A7%E7%BB%84/"/>
    
    <category term="碎碎念" scheme="https://xianmengxi.github.io/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    <category term="轮腿平衡步兵" scheme="https://xianmengxi.github.io/tags/%E8%BD%AE%E8%85%BF%E5%B9%B3%E8%A1%A1%E6%AD%A5%E5%85%B5/"/>
    
  </entry>
  
  <entry>
    <title>轮腿平衡步兵总结 - 代码设计篇</title>
    <link href="https://xianmengxi.github.io/2023/08/26/lun-tui-ping-heng-bu-bing-zong-jie-dai-ma-she-ji-pian/"/>
    <id>https://xianmengxi.github.io/2023/08/26/lun-tui-ping-heng-bu-bing-zong-jie-dai-ma-she-ji-pian/</id>
    <published>2023-08-26T02:00:00.000Z</published>
    <updated>2023-11-21T12:22:09.062Z</updated>
    
    <content type="html"><![CDATA[<h1 id="轮腿平衡步兵总结-代码设计篇"><a href="#轮腿平衡步兵总结-代码设计篇" class="headerlink" title="轮腿平衡步兵总结 - 代码设计篇"></a>轮腿平衡步兵总结 - 代码设计篇</h1><h2 id="代码框架"><a href="#代码框架" class="headerlink" title="代码框架"></a>代码框架</h2><pre class=" language-c"><code class="language-c"><span class="token punctuation">.</span>│   <span class="token punctuation">.</span>gitignore│   LICENSE<span class="token punctuation">.</span>md│   README<span class="token punctuation">.</span>md│├───Algorithm        <span class="token comment" spellcheck="true">//算法封装</span>│   ├───inc│   │       algorithmOfCRC<span class="token punctuation">.</span>h│   │       crc32<span class="token punctuation">.</span>h│   │       kalman_filter<span class="token punctuation">.</span>h│   │       my_filter<span class="token punctuation">.</span>h│   │       Observer<span class="token punctuation">.</span>h│   │       pid<span class="token punctuation">.</span>h│   │       QuaternionEKF<span class="token punctuation">.</span>h│   │       RLS_Identification<span class="token punctuation">.</span>h│   │       SignalGenerator<span class="token punctuation">.</span>h│   │       SystemIdentification<span class="token punctuation">.</span>h│   │       TD<span class="token punctuation">.</span>h│   │       user_lib<span class="token punctuation">.</span>h│   │       wheel_ins<span class="token punctuation">.</span>h│   ││   └───src│           algorithmOfCRC<span class="token punctuation">.</span>c   <span class="token comment" spellcheck="true">// CRC16,CRC8算法</span>│           crc32<span class="token punctuation">.</span>c            <span class="token comment" spellcheck="true">// CRC32算法</span>│           kalman_filter<span class="token punctuation">.</span>c    <span class="token comment" spellcheck="true">// 卡尔曼滤波(感谢玺佬开源)</span>│           my_filter<span class="token punctuation">.</span>c        <span class="token comment" spellcheck="true">// IIR算法以及RC滤波器</span>│           Observer<span class="token punctuation">.</span>c         <span class="token comment" spellcheck="true">// 状态观测器(未完善)</span>│           pid<span class="token punctuation">.</span>c              <span class="token comment" spellcheck="true">// PID算法封装(再次感谢玺佬开源)</span>│           QuaternionEKF<span class="token punctuation">.</span>c    <span class="token comment" spellcheck="true">// IMU滤波算法封装(再再次感谢玺佬开源)</span>│           RLS_Identification<span class="token punctuation">.</span>c  <span class="token comment" spellcheck="true">// 递推最小二乘法封装</span>│           SignalGenerator<span class="token punctuation">.</span>c    <span class="token comment" spellcheck="true">// 信号发生器封装，可以产生各种类型的锯齿波，正弦波以及方波</span>│           SystemIdentification<span class="token punctuation">.</span>c <span class="token comment" spellcheck="true">// 连续阶跃波生成以及连续频率正弦波生成封装</span>│           TD<span class="token punctuation">.</span>c                 <span class="token comment" spellcheck="true">// 跟踪微分器封装(第n次感谢玺佬开源)</span>│           user_lib<span class="token punctuation">.</span>c           <span class="token comment" spellcheck="true">// 最小二乘法封装，死区控制算法等(第n次感谢玺佬开源)</span>│           wheel_ins<span class="token punctuation">.</span>c          <span class="token comment" spellcheck="true">// 轮毂电机反馈与加速度计数据融合算法</span>│├───docs│   │   ina260<span class="token punctuation">.</span>pdf      <span class="token comment" spellcheck="true">// 电流计</span>│   │   轮腿底盘控制V2<span class="token number">.0</span><span class="token punctuation">.</span>pdf <span class="token comment" spellcheck="true">// 底盘控制板原理图</span>│   ││   ├───SD Association│   ││   └───SD协议<span class="token number">2.0</span>├───Mylib         <span class="token comment" spellcheck="true">// 硬件标准库封装</span>│   ├───inc│   │       bluetooth<span class="token punctuation">.</span>h│   │       bsp_referee<span class="token punctuation">.</span>h│   │       bsp_spi_sdcard<span class="token punctuation">.</span>h│   │       bsp_superpower<span class="token punctuation">.</span>h│   │       can1<span class="token punctuation">.</span>h│   │       can1_receive<span class="token punctuation">.</span>h│   │       can2<span class="token punctuation">.</span>h│   │       can2_receive<span class="token punctuation">.</span>h│   │       can_send<span class="token punctuation">.</span>h│   │       counter<span class="token punctuation">.</span>h│   │       i2c<span class="token punctuation">.</span>h│   │       iwdg<span class="token punctuation">.</span>h│   │       led<span class="token punctuation">.</span>h│   │       motor_rs485<span class="token punctuation">.</span>h│   │       os_tick<span class="token punctuation">.</span>h│   │       pc_uart<span class="token punctuation">.</span>h│   │       pin_affine<span class="token punctuation">.</span>h│   │       wifi<span class="token punctuation">.</span>h│   ││   └───src│           bluetooth<span class="token punctuation">.</span>c              <span class="token comment" spellcheck="true">// 蓝牙</span>│           bsp_referee<span class="token punctuation">.</span>c            <span class="token comment" spellcheck="true">// 裁判系统接口</span>│           bsp_spi_sdcard<span class="token punctuation">.</span>c         <span class="token comment" spellcheck="true">// SD卡接口</span>│           bsp_superpower<span class="token punctuation">.</span>c         <span class="token comment" spellcheck="true">// 超级电容接口</span>│           can1<span class="token punctuation">.</span>c                   <span class="token comment" spellcheck="true">// CAN1</span>│           can1_receive<span class="token punctuation">.</span>c│           can2<span class="token punctuation">.</span>c                   <span class="token comment" spellcheck="true">// CAN2</span>│           can2_receive<span class="token punctuation">.</span>c│           can_send<span class="token punctuation">.</span>c              <span class="token comment" spellcheck="true">// CAN发送封装</span>│           counter<span class="token punctuation">.</span>c               <span class="token comment" spellcheck="true">// 定时器，主要用来计算程序耗时，测试通信是否正常等功能</span>│           i2c<span class="token punctuation">.</span>c                   <span class="token comment" spellcheck="true">// I2C通信实现</span>│           iwdg<span class="token punctuation">.</span>c                  <span class="token comment" spellcheck="true">// 看门狗实现</span>│           led<span class="token punctuation">.</span>c                   <span class="token comment" spellcheck="true">// led灯驱动</span>│           motor1_rs485<span class="token punctuation">.</span>c          <span class="token comment" spellcheck="true">// 左(右)关节电机RS485驱动</span>│           motor2_rs485<span class="token punctuation">.</span>c          <span class="token comment" spellcheck="true">// 右(左)关节电机RS485驱动</span>│           os_tick<span class="token punctuation">.</span>c               <span class="token comment" spellcheck="true">// 用于FreeRTOS性能测试的定时器</span>│           pc_uart<span class="token punctuation">.</span>c               <span class="token comment" spellcheck="true">// 与PC通信串口驱动</span>│           wifi<span class="token punctuation">.</span>c                  <span class="token comment" spellcheck="true">// wifi模块驱动</span>├───Task                 <span class="token comment" spellcheck="true">// 任务</span>│   ├───inc│   │       ActionTask<span class="token punctuation">.</span>h│   │       BlueToothTask<span class="token punctuation">.</span>h│   │       ChasisControlTask<span class="token punctuation">.</span>h│   │       ChasisEstimateTask<span class="token punctuation">.</span>h│   │       CPU_Task<span class="token punctuation">.</span>h│   │       GimbalTask<span class="token punctuation">.</span>h│   │       iwdgTask<span class="token punctuation">.</span>h│   │       MF9025_IdentifyTask<span class="token punctuation">.</span>h│   │       Offline_Task<span class="token punctuation">.</span>h│   │       PC_Task<span class="token punctuation">.</span>h│   │       PowerControlTask<span class="token punctuation">.</span>h│   │       RefereeTask<span class="token punctuation">.</span>h│   │       SDCardTask<span class="token punctuation">.</span>h│   │       Start_Task<span class="token punctuation">.</span>h│   │       Test_Task<span class="token punctuation">.</span>h│   │       WheelsAccelFusionTask<span class="token punctuation">.</span>h│   ││   └───src│           ActionTask<span class="token punctuation">.</span>c             <span class="token comment" spellcheck="true">//　完成机器人状态切换逻辑任务</span>│           BlueToothTask<span class="token punctuation">.</span>c          <span class="token comment" spellcheck="true">//  蓝牙传输任务(配合VOFA+实现无线debug)</span>│           ChasisControlTask<span class="token punctuation">.</span>c      <span class="token comment" spellcheck="true">// 底盘控制任务</span>│           ChasisEstimateTask<span class="token punctuation">.</span>c     <span class="token comment" spellcheck="true">// 底盘姿态估计任务</span>│           CPU_Task<span class="token punctuation">.</span>c               <span class="token comment" spellcheck="true">// FreeRTOS CPU占用耗时测试任务</span>│           GimbalTask<span class="token punctuation">.</span>c             <span class="token comment" spellcheck="true">// 热量控制以及与云台控制任务</span>│           iwdgTask<span class="token punctuation">.</span>c               <span class="token comment" spellcheck="true">// 看门狗任务</span>│           MF9025_IdentifyTask<span class="token punctuation">.</span>c    <span class="token comment" spellcheck="true">// MF9025电机系统辨识任务</span>│           Offline_Task<span class="token punctuation">.</span>c           <span class="token comment" spellcheck="true">// 掉线检测任务</span>│           PC_Task<span class="token punctuation">.</span>c                <span class="token comment" spellcheck="true">// 与PC通信任务</span>│           PowerControlTask<span class="token punctuation">.</span>c       <span class="token comment" spellcheck="true">// 功率控制测试任务</span>│           RefereeTask<span class="token punctuation">.</span>c            <span class="token comment" spellcheck="true">// 裁判系统读取任务</span>│           SDCardTask<span class="token punctuation">.</span>c             <span class="token comment" spellcheck="true">// SD卡读写任务</span>│           Start_Task<span class="token punctuation">.</span>c             <span class="token comment" spellcheck="true">// 启动任务</span>│           Test_Task<span class="token punctuation">.</span>c              <span class="token comment" spellcheck="true">// 电路测试任务</span>│           WheelsAccelFusionTask<span class="token punctuation">.</span>c  <span class="token comment" spellcheck="true">// 轮毂电机与加速度计数据融合测试任务</span>│└───User    ├───inc    │   ├───app    │   │       ChasisController<span class="token punctuation">.</span>h    │   │       Gimbal<span class="token punctuation">.</span>h    │   │       GimbalReceive<span class="token punctuation">.</span>h    │   │       GimbalSend<span class="token punctuation">.</span>h    │   │       HeatControl<span class="token punctuation">.</span>h    │   │       ins<span class="token punctuation">.</span>h    │   │       main<span class="token punctuation">.</span>h    │   │       pc_serial<span class="token punctuation">.</span>h    │   │       PowerLimit<span class="token punctuation">.</span>h    │   │       RobotAbnormalDetector<span class="token punctuation">.</span>h    │   │       robotObserver<span class="token punctuation">.</span>h    │   │       ToggleBullet<span class="token punctuation">.</span>h    │   │    │   ├───config    │   │       can_config<span class="token punctuation">.</span>h    <span class="token comment" spellcheck="true">// CAN ID配置</span>    │   │    │   ├───FATFS   <span class="token comment" spellcheck="true">// SD卡相关</span>    │   ├───motor    │   │       GM6020<span class="token punctuation">.</span>h    │   │       M2006<span class="token punctuation">.</span>h    │   │       M3508<span class="token punctuation">.</span>h    │   │       MF9025<span class="token punctuation">.</span>h    │   │       UniTreeA1<span class="token punctuation">.</span>h    │   │    │   ├───os    │   │       FreeRTOSConfig<span class="token punctuation">.</span>h    │   │    │   ├───peripheral    │   │       icm20602<span class="token punctuation">.</span>h    │   │       ina260<span class="token punctuation">.</span>h    │   │       Referee<span class="token punctuation">.</span>h    │   │       remote_control<span class="token punctuation">.</span>h    │   │       SuperPower<span class="token punctuation">.</span>h    │   │    │   ├───sys    │   │       stm32f4xx<span class="token punctuation">.</span>h    │   │       stm32f4xx_conf<span class="token punctuation">.</span>h    │   │       stm32f4xx_it<span class="token punctuation">.</span>h    │   │       system_stm32f4xx<span class="token punctuation">.</span>h    │   │    │   └───tools    │           debug<span class="token punctuation">.</span>h    │           protocol<span class="token punctuation">.</span>h    │           tools<span class="token punctuation">.</span>h    │           ZeroCheck<span class="token punctuation">.</span>h    │    └───src        ├───app        │       ChasisController<span class="token punctuation">.</span>c    <span class="token comment" spellcheck="true">// 底盘控制算法</span>        │       Gimbal<span class="token punctuation">.</span>c              <span class="token comment" spellcheck="true">// 云台控制算法(下供弹控yaw轴用，已弃用)</span>        │       GimbalReceive<span class="token punctuation">.</span>c       <span class="token comment" spellcheck="true">// 接收云台信息</span>        │       GimbalSend<span class="token punctuation">.</span>c          <span class="token comment" spellcheck="true">// 发送给云台信息</span>        │       HeatControl<span class="token punctuation">.</span>c         <span class="token comment" spellcheck="true">// 热量控制</span>        │       ins<span class="token punctuation">.</span>c                 <span class="token comment" spellcheck="true">// INS,IMU滤波算法</span>        │       main<span class="token punctuation">.</span>c                <span class="token comment" spellcheck="true">// 程序进口</span>        │       pc_serial<span class="token punctuation">.</span>c           <span class="token comment" spellcheck="true">// 与PC通信接口</span>        │       PowerLimit<span class="token punctuation">.</span>c          <span class="token comment" spellcheck="true">// 功率限制，电容控制接口</span>        │       RobotAbnormalDetector<span class="token punctuation">.</span>c  <span class="token comment" spellcheck="true">// 异常观测</span>        │       robotObserver<span class="token punctuation">.</span>c        <span class="token comment" spellcheck="true">// 机器人状态观测器</span>        │       ToggleBullet<span class="token punctuation">.</span>c        <span class="token comment" spellcheck="true">// 拨弹电机控制</span>        │        ├───motor        │       GM6020<span class="token punctuation">.</span>c             <span class="token comment" spellcheck="true">// 6020电机驱动</span>        │       M2006<span class="token punctuation">.</span>c              <span class="token comment" spellcheck="true">// 2006电机驱动</span>        │       M3508<span class="token punctuation">.</span>c              <span class="token comment" spellcheck="true">// 3508电机驱动</span>        │       MF9025<span class="token punctuation">.</span>c             <span class="token comment" spellcheck="true">// 9025电机驱动</span>        │       UniTreeA1<span class="token punctuation">.</span>c          <span class="token comment" spellcheck="true">// A1电机驱动</span>        │        ├───peripheral        │       icm20602<span class="token punctuation">.</span>c           <span class="token comment" spellcheck="true">// IMU</span>        │       ina260<span class="token punctuation">.</span>c             <span class="token comment" spellcheck="true">// 电流计</span>        │       Referee<span class="token punctuation">.</span>c            <span class="token comment" spellcheck="true">// 裁判系统</span>        │       remote_control<span class="token punctuation">.</span>c     <span class="token comment" spellcheck="true">// 遥控器</span>        │       SuperPower<span class="token punctuation">.</span>c         <span class="token comment" spellcheck="true">// 超级电容</span>        │        ├───sys                          <span class="token comment" spellcheck="true">//系统文件</span>        │       startup_stm32f40_41xxx<span class="token punctuation">.</span>s        │       stm32f4xx_it<span class="token punctuation">.</span>c        │       system_stm32f4xx<span class="token punctuation">.</span>c        │        └───tools                debug<span class="token punctuation">.</span>c              <span class="token comment" spellcheck="true">// 全局debug器，用于快速定位传感器错误</span>                tools<span class="token punctuation">.</span>c              <span class="token comment" spellcheck="true">// 延时封装</span>                ZeroCheck<span class="token punctuation">.</span>c          <span class="token comment" spellcheck="true">// 过零检测</span></code></pre><h2 id="代码启动逻辑"><a href="#代码启动逻辑" class="headerlink" title="代码启动逻辑"></a>代码启动逻辑</h2><p><img src="/2023/08/26/lun-tui-ping-heng-bu-bing-zong-jie-dai-ma-she-ji-pian/2023-08-22-11-30-20.png"></p><h2 id="标准库封装"><a href="#标准库封装" class="headerlink" title="标准库封装"></a>标准库封装</h2><p>在实际应用中，可能会因为板子上引脚复用不同而使标准库修改十分麻烦，故在平衡步兵代码中，统一封装了标准库，即将大部分需要修改的东西都放在.h 文件中，防止大面积修改代码引发的错误。</p><p>例如 can1.h 中，若需要修改复用的 GPIO 口，修改以下宏定义即可。</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/*  params */</span><span class="token macro property">#<span class="token directive keyword">define</span> CAN1_RCC_AHBx_GPIOx RCC_AHB1Periph_GPIOA</span><span class="token macro property">#<span class="token directive keyword">define</span> CAN1_GPIOx GPIOA</span><span class="token macro property">#<span class="token directive keyword">define</span> CAN1_GPIO_PinSource_x1 GPIO_PinSource11</span><span class="token macro property">#<span class="token directive keyword">define</span> CAN1_GPIO_PinSource_x2 GPIO_PinSource12</span><span class="token macro property">#<span class="token directive keyword">define</span> CAN1_GPIO_Pin_x1 GPIO_Pin_11</span><span class="token macro property">#<span class="token directive keyword">define</span> CAN1_GPIO_Pin_x2 GPIO_Pin_12</span><span class="token comment" spellcheck="true">/* GPIO特性设置到特定的位置修改 */</span><span class="token comment" spellcheck="true">/* NVIC优先级到特定位置修改 */</span><span class="token comment" spellcheck="true">/* CAN1特性配置到特定位置修改 */</span><span class="token comment" spellcheck="true">/* 过滤器的其它设置到特定位置改 */</span></code></pre><h2 id="串口接发设计"><a href="#串口接发设计" class="headerlink" title="串口接发设计"></a>串口接发设计</h2><p>以串口发送给 VOFA+的数据为例，#pragma pack(push, 1)设定一字节对齐(否则会默认四字节对齐，不能使用 memcpy 操作)。</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">pragma</span> pack(push, 1)</span><span class="token macro property">#<span class="token directive keyword">define</span> CH_COUNT_B 6</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> BlueToothSendData<span class="token punctuation">{</span>    <span class="token keyword">float</span> fdata<span class="token punctuation">[</span>CH_COUNT_B<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> tail<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span> BlueToothSendData<span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">pragma</span> pack(pop)</span></code></pre><p>这样的话，便可以使用 memcpy 函数直接将数据一次性复制到发送的缓冲区中，操作十分“优雅”。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">BLUE_TOOTHSendData</span><span class="token punctuation">(</span>BlueToothSendData <span class="token operator">*</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">DMA_GetCmdStatus</span><span class="token punctuation">(</span>BLUE_TOOTH_SEND_DMAx_Streamx<span class="token punctuation">)</span> <span class="token operator">==</span> ENABLE<span class="token punctuation">)</span>        <span class="token punctuation">;</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>BlueToothSend_Buff<span class="token punctuation">,</span> data<span class="token punctuation">,</span> BlueTooth_SENDBUF_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    BlueToothSend_Buff<span class="token punctuation">[</span>BlueTooth_SENDBUF_SIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0x7f</span><span class="token punctuation">;</span>    BlueToothSend_Buff<span class="token punctuation">[</span>BlueTooth_SENDBUF_SIZE <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0x80</span><span class="token punctuation">;</span>    BlueToothSend_Buff<span class="token punctuation">[</span>BlueTooth_SENDBUF_SIZE <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0x00</span><span class="token punctuation">;</span>    BlueToothSend_Buff<span class="token punctuation">[</span>BlueTooth_SENDBUF_SIZE <span class="token operator">-</span> <span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0x00</span><span class="token punctuation">;</span>    <span class="token function">DMA_SetCurrDataCounter</span><span class="token punctuation">(</span>BLUE_TOOTH_SEND_DMAx_Streamx<span class="token punctuation">,</span> BlueTooth_SENDBUF_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">DMA_Cmd</span><span class="token punctuation">(</span>BLUE_TOOTH_SEND_DMAx_Streamx<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="裁判系统数据接收设计"><a href="#裁判系统数据接收设计" class="headerlink" title="裁判系统数据接收设计"></a>裁判系统数据接收设计</h2><p>接受使用 DMA_Mode_Circular 模式，当数据过一圈时圈数加一。</p><pre class=" language-c"><code class="language-c">referee_data<span class="token punctuation">.</span>decoder<span class="token punctuation">.</span>receive_data_len <span class="token operator">=</span> REFEREE_RECVBUF_SIZE <span class="token operator">-</span> <span class="token function">DMA_GetCurrDataCounter</span><span class="token punctuation">(</span>REFEREE_RECV_DMAx_Streamx<span class="token punctuation">)</span> <span class="token operator">+</span> referee_data<span class="token punctuation">.</span>decoder<span class="token punctuation">.</span>judgementFullCount <span class="token operator">*</span> REFEREE_RECVBUF_SIZE<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>referee_data<span class="token punctuation">.</span>decoder<span class="token punctuation">.</span>receive_data_len <span class="token operator">-</span> referee_data<span class="token punctuation">.</span>decoder<span class="token punctuation">.</span>decode_data_len <span class="token operator">></span> <span class="token number">2</span> <span class="token operator">*</span> REFEREE_RECVBUF_SIZE<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        referee_data<span class="token punctuation">.</span>decoder<span class="token punctuation">.</span>decode_data_len <span class="token operator">=</span> referee_data<span class="token punctuation">.</span>decoder<span class="token punctuation">.</span>receive_data_len <span class="token operator">-</span> <span class="token number">2</span> <span class="token operator">*</span> REFEREE_RECVBUF_SIZE<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> read_arr <span class="token operator">=</span> referee_data<span class="token punctuation">.</span>decoder<span class="token punctuation">.</span>decode_data_len <span class="token operator">%</span> REFEREE_RECVBUF_SIZE<span class="token punctuation">;</span></code></pre><p>代码通过对比收到的数据长度以及已经解码的数据长度进行处理，解码数与接受数相差过大，则可以使解码长度&#x3D;接收长度-圈长度来使不重复解码。</p><p>该解码采用的是单字节解码形式，好处在于大大降低了丢包的几率。</p><pre class=" language-c"><code class="language-c">        UI_PushUp_Counter<span class="token operator">++</span><span class="token punctuation">;</span>        UI_PushUp_Counter_500 <span class="token operator">=</span> UI_PushUp_Counter <span class="token operator">%</span> <span class="token number">500</span><span class="token punctuation">;</span>        UI_PushUp_Counter_20 <span class="token operator">=</span> UI_PushUp_Counter <span class="token operator">%</span> <span class="token number">20</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>UI_PushUp_Counter_500 <span class="token operator">==</span> <span class="token number">37</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token function">UI_Draw_String</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>referee_data<span class="token punctuation">.</span>UI_String<span class="token punctuation">.</span>String<span class="token punctuation">,</span> <span class="token string">"001"</span><span class="token punctuation">,</span> UI_Graph_Add<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> UI_Color_Green<span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1600</span><span class="token punctuation">,</span> <span class="token number">800</span><span class="token punctuation">,</span> <span class="token string">"  FRIC "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">UI_PushUp_String</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>referee_data<span class="token punctuation">.</span>UI_String<span class="token punctuation">,</span> referee_data<span class="token punctuation">.</span>Game_Robot_State<span class="token punctuation">.</span>robot_id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span></code></pre><p>发送绘制 UI 则是通过定时发送完成，这样可以不需要按键对 UI 进行初始化，但缺点是有时候 UI 更新不太及时(这是一个比较重要的问题，目前还没找到解决方案)。</p><h2 id="全局-Debug-器"><a href="#全局-Debug-器" class="headerlink" title="全局 Debug 器"></a>全局 Debug 器</h2><p>代码定义了一个可以进行全局 debug 的结构体，通过 Keil 可以观察到结构体的内容，以判断传感器是否存在丢帧等现象，以及收发是否正常等等。</p><pre class=" language-c"><code class="language-c">GlobalDebugger global_debugger<span class="token punctuation">;</span></code></pre><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> Motor_SendReceive_Debugger<span class="token punctuation">{</span>    uint16_t send_msgs_num<span class="token punctuation">;</span>    uint16_t recv_msgs_num<span class="token punctuation">;</span>    uint16_t loss_num<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//丢帧数</span>    <span class="token comment" spellcheck="true">/*  接收帧率计算定义 */</span>    uint32_t last_can_cnt<span class="token punctuation">;</span>    <span class="token keyword">float</span> can_dt<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//前后两帧时间差</span><span class="token punctuation">}</span> Motor_SendReceive_Debugger<span class="token punctuation">;</span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;轮腿平衡步兵总结-代码设计篇&quot;&gt;&lt;a href=&quot;#轮腿平衡步兵总结-代码设计篇&quot; class=&quot;headerlink&quot; title=&quot;轮腿平衡步兵总结 - 代码设计篇&quot;&gt;&lt;/a&gt;轮腿平衡步兵总结 - 代码设计篇&lt;/h1&gt;&lt;h2 id=&quot;代码框架&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="RoboMaster" scheme="https://xianmengxi.github.io/categories/RoboMaster/"/>
    
    
    <category term="RoboMaster" scheme="https://xianmengxi.github.io/tags/RoboMaster/"/>
    
    <category term="电控组" scheme="https://xianmengxi.github.io/tags/%E7%94%B5%E6%8E%A7%E7%BB%84/"/>
    
    <category term="轮腿平衡步兵" scheme="https://xianmengxi.github.io/tags/%E8%BD%AE%E8%85%BF%E5%B9%B3%E8%A1%A1%E6%AD%A5%E5%85%B5/"/>
    
    <category term="代码设计" scheme="https://xianmengxi.github.io/tags/%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>轮腿平衡步兵总结 - 控制算法篇</title>
    <link href="https://xianmengxi.github.io/2023/08/26/lun-tui-ping-heng-bu-bing-zong-jie-kong-zhi-suan-fa-pian/"/>
    <id>https://xianmengxi.github.io/2023/08/26/lun-tui-ping-heng-bu-bing-zong-jie-kong-zhi-suan-fa-pian/</id>
    <published>2023-08-26T02:00:00.000Z</published>
    <updated>2023-11-21T12:19:49.825Z</updated>
    
    <content type="html"><![CDATA[<h1 id="轮腿平衡步兵总结-控制算法篇"><a href="#轮腿平衡步兵总结-控制算法篇" class="headerlink" title="轮腿平衡步兵总结 - 控制算法篇"></a>轮腿平衡步兵总结 - 控制算法篇</h1><h2 id="卡尔曼滤波"><a href="#卡尔曼滤波" class="headerlink" title="卡尔曼滤波"></a>卡尔曼滤波</h2><p>学习可以参考该<a href="https://www.bilibili.com/video/BV1ez4y1X7eR/?spm_id_from=333.337.search-card.all.click&vd_source=c9ad8e271fb7bd801090950dd31af8e5">视频</a></p><p>代码中执行卡尔曼滤波黄金五式,提供了用户定义函数,可以替代五个中的任意一个环节,方便自行扩展为 EKF&#x2F;UKF&#x2F;ESKF&#x2F;AUKF 等。</p><h2 id="龙贝格观测器"><a href="#龙贝格观测器" class="headerlink" title="龙贝格观测器"></a>龙贝格观测器</h2><p>Observer.c 中封装了龙贝格观测器，开始是想用来通过状态空间方程估计不可观测量(例如 pitch 速度)，但实际调试效果并不好，后面可以在此基础上重新探索一下。</p><h2 id="PID-算法"><a href="#PID-算法" class="headerlink" title="PID 算法"></a>PID 算法</h2><p>该 PID 算法封装了多种 PID 优化算法，初始化例子如下</p><pre class=" language-c"><code class="language-c">    <span class="token function">PID_Init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>balance_infantry<span class="token operator">-></span>turn_pid<span class="token punctuation">,</span> SPEED_W_MAX<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0.001</span><span class="token punctuation">,</span> <span class="token number">0.009</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> DerivativeFilter <span class="token operator">|</span> OutputFilter<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>说明使用了输出滤波和不完全微分两种优化。</p><p>该 PID 算法需要特别注意 dt 对积分项和差分项的影响，当掉线模式下，需要使用 PID_Clear 函数消去 PID 的积分项。</p><h2 id="IMU-滤波算法"><a href="#IMU-滤波算法" class="headerlink" title="IMU 滤波算法"></a>IMU 滤波算法</h2><p>参考<a href="https://github.com/WangHongxi2001/RoboMaster-C-Board-INS-Example">哈尔滨工程大学的开源</a></p><h2 id="递推最小二乘法"><a href="#递推最小二乘法" class="headerlink" title="递推最小二乘法"></a>递推最小二乘法</h2><p>参考<a href="https://zhuanlan.zhihu.com/p/111758532">递推最小二乘法推导（RLS）</a></p><p>该算法并不算调试通过，可能存在一些 bug，若需要使用该算法，可以在该基础上修改使用。</p><h2 id="信号发生器"><a href="#信号发生器" class="headerlink" title="信号发生器"></a>信号发生器</h2><p>在 SignalGenerator.c 中封装了锯齿波，正弦波，阶跃波三种信号，可用作调试 PID(例如调试云台时可使用锯齿波模拟反陀螺时的输入信号)。</p><h2 id="系统辨识信号"><a href="#系统辨识信号" class="headerlink" title="系统辨识信号"></a>系统辨识信号</h2><p>基于信号发生器封装的，不同频率正弦波输入信号。</p><h2 id="跟踪微分器"><a href="#跟踪微分器" class="headerlink" title="跟踪微分器"></a>跟踪微分器</h2><p>参考<a href="https://zhuanlan.zhihu.com/p/511275301">【ADRC】跟踪微分器</a></p><h2 id="里程计与加速度计数据融合算法设计"><a href="#里程计与加速度计数据融合算法设计" class="headerlink" title="里程计与加速度计数据融合算法设计"></a>里程计与加速度计数据融合算法设计</h2><p>由于平衡步兵轮子或多或少存在打滑现象，故里程计的数据并非完全可信，故需要依靠底盘 IMU 的加速度计来和里程计数据进行融合来得到较为准确的轮子里程计信息。</p><p>在卡尔曼滤波中的式子之中</p><p>$$<br>    x_{k+1} &#x3D; A x_k + B u_k<br>$$</p><p>其中</p><p>$$<br>    x_k &#x3D; [x,x_v]^T<br>$$</p><p>x 为位移，即平衡步兵状态变量的位移量。$x_v$为速度，即平衡步兵状态变量的速度量，$x_a$为加速度计观测量。</p><p>$$<br>    A &#x3D; \begin{bmatrix}<br>    1 &amp; dt \ 0 &amp; 1<br>    \end{bmatrix}<br>$$</p><p>$$<br>    B &#x3D; [0.5 * (dt)^2 , dt]^T<br>$$</p><p>$$<br>    u_k &#x3D; x_a<br>$$</p><p>而对于观测方程</p><p>$$<br>    z_k &#x3D; H x_k<br>$$</p><p>$$<br>    H &#x3D; \begin{bmatrix}<br>        0 &amp; 1<br>    \end{bmatrix}<br>$$</p><h2 id="平衡步兵控制算法"><a href="#平衡步兵控制算法" class="headerlink" title="平衡步兵控制算法"></a>平衡步兵控制算法</h2><p>参考<a href="https://zhuanlan.zhihu.com/p/563048952">RoboMaster 平衡步兵机器人控制系统设计</a>以及<a href="https://www.bilibili.com/video/BV1Hk4y1h7r8/?spm_id_from=333.999.0.0">五连杆解算</a></p><h3 id="速度获取算法"><a href="#速度获取算法" class="headerlink" title="速度获取算法"></a>速度获取算法</h3><pre class=" language-c"><code class="language-c">    <span class="token comment" spellcheck="true">// 得到速度的方法1： 一阶低通滤波</span>    <span class="token function">rc_filter</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>balance_infantry<span class="token operator">-></span>state_vector<span class="token punctuation">[</span>STATE_PITCH_V<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>balance_infantry<span class="token operator">-></span>state_vector<span class="token punctuation">[</span>STATE_PITCH<span class="token punctuation">]</span> <span class="token operator">-</span> balance_infantry<span class="token operator">-></span>pitch_last<span class="token punctuation">)</span> <span class="token operator">/</span> balance_infantry<span class="token operator">-></span>delta_t<span class="token punctuation">,</span> balance_infantry<span class="token operator">-></span>delta_t<span class="token punctuation">,</span> LP_PITCH_V_RC<span class="token punctuation">)</span><span class="token punctuation">;</span>    balance_infantry<span class="token operator">-></span>pitch_last <span class="token operator">=</span> balance_infantry<span class="token operator">-></span>sensors_info<span class="token punctuation">.</span>pitch<span class="token punctuation">;</span></code></pre><p>该代码中，直接使用差分然后低通滤波获取其速度，速度滞后较为严重且不够准确，可以考虑使用观测器来获取速度(类似于卡尔曼滤波 CV 运动模型)。</p><h3 id="斜坡变腿长算法"><a href="#斜坡变腿长算法" class="headerlink" title="斜坡变腿长算法"></a>斜坡变腿长算法</h3><p><img src="/2023/08/26/lun-tui-ping-heng-bu-bing-zong-jie-kong-zhi-suan-fa-pian/1.jpg"></p><h3 id="腿长控制思想"><a href="#腿长控制思想" class="headerlink" title="腿长控制思想"></a>腿长控制思想</h3><p>腿可以看作是一个模拟弹簧阻尼系统，其中 P 决定了系统的刚度，D 决定了系统的阻尼，同时利用前馈补偿系统重力，利用积分项来消除各种其它外来因素导致的误差。</p><p>起跳过程本质上是多过程的腿长控制过程，在起跳的准备阶段，需要低刚度高阻尼的 PID 来压缩腿长(即机器人下蹲)，同时储存能量；在起跳的启动阶段，需要高刚度低阻尼的 PID 来快速增加腿长长度形成足够的爆发力；在机器人即将离地时，需要高刚度低阻尼的 PID 来快速收回机器人的腿，以使机器人的轮子快速远离地面；在机器人落地时，则需要低刚度高阻尼的 PID 来进行落地时的“缓冲”作用。</p><h3 id="关键参数调整"><a href="#关键参数调整" class="headerlink" title="关键参数调整"></a>关键参数调整</h3><ul><li><p>MAX_VMC_TORQUE 该参数决定了最大的摆动力矩，若该力矩过大，则可能因为位移期望与实际值过大导致腿部发散。若该值过小，则在上坡时扭矩可能会不够导致车身角度过大飞坡失败。</p></li><li><p>MAX_VMC_FORCE 该参数决定了最大力，PID 里还限制了比 MAX_VMC_FORCE 还小的最大输出力，故该参数只在起跳时起最大限幅作用。</p></li></ul><h3 id="细节处理"><a href="#细节处理" class="headerlink" title="细节处理"></a>细节处理</h3><pre class=" language-c"><code class="language-c"><span class="token function">getMaxXLimit</span><span class="token punctuation">(</span>balance_infantry<span class="token punctuation">)</span><span class="token punctuation">;</span>balance_infantry<span class="token operator">-></span>target_vector<span class="token punctuation">[</span>STATE_X<span class="token punctuation">]</span> <span class="token operator">=</span> balance_infantry<span class="token operator">-></span>state_vector<span class="token punctuation">[</span>STATE_X<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token function">LIMIT_MAX_MIN</span><span class="token punctuation">(</span>balance_infantry<span class="token operator">-></span>target_vector<span class="token punctuation">[</span>STATE_X<span class="token punctuation">]</span> <span class="token operator">-</span> balance_infantry<span class="token operator">-></span>state_vector<span class="token punctuation">[</span>STATE_X<span class="token punctuation">]</span><span class="token punctuation">,</span>balance_infantry<span class="token operator">-></span>limit_err_x_max<span class="token punctuation">,</span> balance_infantry<span class="token operator">-></span>limit_err_x_min<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">getMaxXLimit</span><span class="token punctuation">(</span>BalanceInfantry <span class="token operator">*</span>balance_infantry<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">const</span> <span class="token keyword">static</span> <span class="token keyword">float</span> x_limit <span class="token operator">=</span> <span class="token number">1.3f</span><span class="token punctuation">;</span>    <span class="token keyword">float</span> temp_x_v <span class="token operator">=</span> <span class="token function">LIMIT_MAX_MIN</span><span class="token punctuation">(</span>balance_infantry<span class="token operator">-></span>state_vector<span class="token punctuation">[</span>STATE_X_V<span class="token punctuation">]</span><span class="token punctuation">,</span> x_limit<span class="token punctuation">,</span> <span class="token operator">-</span>x_limit<span class="token punctuation">)</span><span class="token punctuation">;</span>    balance_infantry<span class="token operator">-></span>limit_err_x_max <span class="token operator">=</span> temp_x_v <span class="token operator">+</span> x_limit<span class="token punctuation">;</span>    balance_infantry<span class="token operator">-></span>limit_err_x_min <span class="token operator">=</span> temp_x_v <span class="token operator">-</span> x_limit<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>该算法核心思想是将期望 x 值与实际 x 值的差值限制在一定范围以内，而且该限制还会将当前速度考虑在内，即当前速度越大，所允许的差值就越大，从而避免了期望 x 值与实际 x 值的差值过大导致的系统发散。</p><h2 id="目前尚存在问题总结"><a href="#目前尚存在问题总结" class="headerlink" title="目前尚存在问题总结"></a>目前尚存在问题总结</h2><ol><li><p>转向控制的不稳定性，即在小陀螺状态下无法保持在原地旋转，这可能是因为控制时是将力矩相反地叠加到左右轮子扭矩中，这并不保证两个轮子的转速相同，故会因为电机特性，轮子特性，机器人本身机械特性导致两个轮子存在速度差而不能转速相同。</p></li><li><p>旋转与前后移动未完全解耦，这会导致若前后移动过程中开启小陀螺状态出现翻车现象。</p></li><li><p>转向过程中很明显会存在两腿长度交替变长变短过程，这可能是因为斜坡变腿长算法存在一定的问题，也可能是 roll 轴控制的 PID 参数 P 过大导致的。</p></li><li><p>赛场上并没有跑出平衡步兵的最大速度，在新的被动电容研发出来之后，需要优化一下机器人速度。</p></li><li><p>离地检测不够稳定，导致下落凤坡时腿部角度过大直接进入保护状态(虽然能站起来但下得不够丝滑)。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;轮腿平衡步兵总结-控制算法篇&quot;&gt;&lt;a href=&quot;#轮腿平衡步兵总结-控制算法篇&quot; class=&quot;headerlink&quot; title=&quot;轮腿平衡步兵总结 - 控制算法篇&quot;&gt;&lt;/a&gt;轮腿平衡步兵总结 - 控制算法篇&lt;/h1&gt;&lt;h2 id=&quot;卡尔曼滤波&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="RoboMaster" scheme="https://xianmengxi.github.io/categories/RoboMaster/"/>
    
    
    <category term="RoboMaster" scheme="https://xianmengxi.github.io/tags/RoboMaster/"/>
    
    <category term="电控组" scheme="https://xianmengxi.github.io/tags/%E7%94%B5%E6%8E%A7%E7%BB%84/"/>
    
    <category term="轮腿平衡步兵" scheme="https://xianmengxi.github.io/tags/%E8%BD%AE%E8%85%BF%E5%B9%B3%E8%A1%A1%E6%AD%A5%E5%85%B5/"/>
    
    <category term="控制算法" scheme="https://xianmengxi.github.io/tags/%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>轮腿平衡步兵总结 - 调试工具篇</title>
    <link href="https://xianmengxi.github.io/2023/08/22/lun-tui-ping-heng-bu-bing-zong-jie-diao-shi-gong-ju-pian/"/>
    <id>https://xianmengxi.github.io/2023/08/22/lun-tui-ping-heng-bu-bing-zong-jie-diao-shi-gong-ju-pian/</id>
    <published>2023-08-22T02:00:00.000Z</published>
    <updated>2023-11-21T12:19:44.941Z</updated>
    
    <content type="html"><![CDATA[<h1 id="轮腿平衡步兵总结-调试工具篇"><a href="#轮腿平衡步兵总结-调试工具篇" class="headerlink" title="轮腿平衡步兵总结 - 调试工具篇"></a>轮腿平衡步兵总结 - 调试工具篇</h1><h2 id="J-link-RTT"><a href="#J-link-RTT" class="headerlink" title="J-link RTT"></a>J-link RTT</h2><p>若需要明白如何部署 J-link RTT Viewer 或者如何使用，请查阅该文章<a href="https://blog.csdn.net/hxj0323/article/details/108294267">STM32 实现 SEGGER RTT 打印</a></p><p>在平衡步兵代码中，可以通过定义宏定义 DEBUG_MODE 来使能 RTT Viewer 功能。</p><p>通过宏定义的封装，可以实现日志形式的输出。</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">// RTT</span><span class="token macro property">#<span class="token directive keyword">define</span> PRINTF(str, ...)       \    SEGGER_RTT_SetTerminal(0); \    SEGGER_RTT_printf(0, str, ##__VA_ARGS__) </span><span class="token comment" spellcheck="true">// 字符串发送</span><span class="token macro property">#<span class="token directive keyword">define</span> PRINTF_F(str_temp, str, format) \    sprintf(str_temp, str, format);     \    SEGGER_RTT_SetTerminal(0);          \    SEGGER_RTT_printf(0, str_temp); </span><span class="token comment" spellcheck="true">// 带浮点数的发送</span><span class="token macro property">#<span class="token directive keyword">define</span> LOG_PROTO(window, type, color, format, ...)     \    SEGGER_RTT_printf(window, "  %s%s" format "\r\n%s", \                      color,                            \                      type,                             \                      ##__VA_ARGS__,                    \                      RTT_CTRL_RESET)</span><span class="token comment" spellcheck="true">/* 清屏*/</span><span class="token macro property">#<span class="token directive keyword">define</span> LOG_CLEAR() SEGGER_RTT_WriteString(0, "  " RTT_CTRL_CLEAR)</span><span class="token comment" spellcheck="true">/* 无颜色日志输出 */</span><span class="token macro property">#<span class="token directive keyword">define</span> LOG(format, ...) LOG_PROTO(0, "", "", format, ##__VA_ARGS__)</span><span class="token comment" spellcheck="true">/* 有颜色格式日志输出 */</span><span class="token macro property">#<span class="token directive keyword">define</span> LOG_INFO(format, ...) LOG_PROTO(0, "[INFO]: ", RTT_CTRL_TEXT_BRIGHT_GREEN, format, ##__VA_ARGS__)</span><span class="token macro property">#<span class="token directive keyword">define</span> LOG_WARNING(format, ...) LOG_PROTO(0, "[WARNING]: ", RTT_CTRL_TEXT_BRIGHT_YELLOW, format, ##__VA_ARGS__)</span><span class="token macro property">#<span class="token directive keyword">define</span> LOG_ERROR(format, ...) LOG_PROTO(0, "[ERROR]: ", RTT_CTRL_TEXT_BRIGHT_RED, format, ##__VA_ARGS__)</span><span class="token macro property">#<span class="token directive keyword">define</span> LOG_FATAL(format, ...) LOG_PROTO(0, "[FATAL]: ", RTT_CTRL_TEXT_BRIGHT_BLUE, format, ##__VA_ARGS__)</span></code></pre><h2 id="Jscope-RTT-Mode"><a href="#Jscope-RTT-Mode" class="headerlink" title="Jscope RTT Mode"></a>Jscope RTT Mode</h2><p>该模式主要实现高速曲线绘制，可以参考以下博客:<a href="https://zhuanlan.zhihu.com/p/646780354">利用 J-Scope RTT 模式实现高速（20K）曲线打印</a></p><p>在平衡步兵代码中，可以通过定义宏定义 JSCOPE_RTT_MODE 来使能 Jscope RTT Mode 功能。</p><h2 id="FreeRTOS-性能测试模块"><a href="#FreeRTOS-性能测试模块" class="headerlink" title="FreeRTOS 性能测试模块"></a>FreeRTOS 性能测试模块</h2><p>该模块可以统计每个任务占用的 CPU 占有率，以及每个任务的堆栈使用情况，可以通过该模块判断哪个任务占用 CPU 时间长从而合理优化其运行时间，通过判断任务堆栈使用剩余量来增加或减少给予该任务的堆栈大小。</p><p>参考该博客<a href="https://blog.csdn.net/qq_36347513/article/details/112219602">FreeRTOS 学习笔记（11）——CPU 使用率统计</a></p><p>在平衡步兵代码中，可以通过定义宏定义 DEBUG_MODE_FREERTOS 来使能 FreeRTOS 性能测试模块。</p><h2 id="计时器模块"><a href="#计时器模块" class="headerlink" title="计时器模块"></a>计时器模块</h2><p>在平衡步兵代码中，采用了 TIM2 作为一个单独的计时器，该计时器主要用来实现精准延时，辅助 debug 使用。</p><h3 id="丢帧估计"><a href="#丢帧估计" class="headerlink" title="丢帧估计"></a>丢帧估计</h3><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/** * @brief 计算两次调用之间的时间差 * @param[in] cnt_last 上一次计数值 */</span><span class="token keyword">float</span> <span class="token function">GetDeltaT</span><span class="token punctuation">(</span>uint32_t <span class="token operator">*</span>cnt_last<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">volatile</span> uint32_t cnt_now <span class="token operator">=</span> COUNTER_TIMx<span class="token operator">-></span>CNT<span class="token punctuation">;</span>    <span class="token keyword">float</span> dt <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>uint32_t<span class="token punctuation">)</span><span class="token punctuation">(</span>cnt_now <span class="token operator">-</span> <span class="token operator">*</span>cnt_last<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token punctuation">(</span>COUNTER_SAMPLING<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">*</span>cnt_last <span class="token operator">=</span> cnt_now<span class="token punctuation">;</span>    <span class="token keyword">return</span> dt<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>以上函数能算出两次调用之间的耗时，通过该耗时能够判断帧率是否符合要求以及丢帧帧数判断。例如:</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">LossUpdate</span><span class="token punctuation">(</span>Loss_Debugger <span class="token operator">*</span>loss_debugger<span class="token punctuation">,</span> <span class="token keyword">float</span> thresh_t<span class="token punctuation">)</span><span class="token punctuation">{</span>    loss_debugger<span class="token operator">-></span>recv_msgs_num<span class="token operator">++</span><span class="token punctuation">;</span>    loss_debugger<span class="token operator">-></span>can_dt <span class="token operator">=</span> <span class="token function">GetDeltaT</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>loss_debugger<span class="token operator">-></span>last_can_cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>loss_debugger<span class="token operator">-></span>can_dt <span class="token operator">></span> thresh_t<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        loss_debugger<span class="token operator">-></span>loss_num<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="程序耗时估计"><a href="#程序耗时估计" class="headerlink" title="程序耗时估计"></a>程序耗时估计</h3><pre class=" language-c"><code class="language-c">    <span class="token function">GetDeltaT</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>global_debugger<span class="token punctuation">.</span>robot_debugger<span class="token punctuation">.</span>last_cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">KF_Wheel_Accel_Update</span><span class="token punctuation">(</span>speed<span class="token punctuation">,</span>                              balance_infantry<span class="token punctuation">.</span>INS<span class="token operator">-></span>MotionAccel_n<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0.001</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    global_debugger<span class="token punctuation">.</span>robot_debugger<span class="token punctuation">.</span>dt <span class="token operator">=</span> <span class="token function">GetDeltaT</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>global_debugger<span class="token punctuation">.</span>robot_debugger<span class="token punctuation">.</span>last_cnt<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="精准延时"><a href="#精准延时" class="headerlink" title="精准延时"></a>精准延时</h3><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/** * @brief 延时 /us * @param[in] void */</span><span class="token keyword">void</span> <span class="token function">Delay</span><span class="token punctuation">(</span>uint32_t Delay<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">volatile</span> uint32_t tickstart <span class="token operator">=</span> COUNTER_TIMx<span class="token operator">-></span>CNT<span class="token punctuation">;</span>    uint32_t wait <span class="token operator">=</span> Delay<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>COUNTER_TIMx<span class="token operator">-></span>CNT <span class="token operator">-</span> tickstart<span class="token punctuation">)</span> <span class="token operator">&lt;</span> wait<span class="token punctuation">)</span>    <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">DelayTo</span><span class="token punctuation">(</span><span class="token keyword">volatile</span> uint32_t <span class="token operator">*</span>tickstart<span class="token punctuation">,</span> uint32_t Delay<span class="token punctuation">)</span><span class="token punctuation">{</span>    uint32_t wait <span class="token operator">=</span> Delay<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>COUNTER_TIMx<span class="token operator">-></span>CNT <span class="token operator">-</span> <span class="token operator">*</span>tickstart<span class="token punctuation">)</span> <span class="token operator">&lt;</span> wait<span class="token punctuation">)</span>    <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="LED"><a href="#LED" class="headerlink" title="LED"></a>LED</h2><p>调试时，可通过 LED 的亮灯情况判断当前机器人的状态。通过以下宏定义封装：</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> LED_R_RCC_AHBxPeriphClockCmd RCC_AHB1PeriphClockCmd</span><span class="token macro property">#<span class="token directive keyword">define</span> LED_R_RCC_AHBxPeriph_GPIOx RCC_AHB1Periph_GPIOC</span><span class="token macro property">#<span class="token directive keyword">define</span> LED_R_GPIOx GPIOC</span><span class="token macro property">#<span class="token directive keyword">define</span> LED_R_GPIO_Pin_x GPIO_Pin_9</span><span class="token macro property">#<span class="token directive keyword">define</span> LED_B_RCC_AHBxPeriphClockCmd RCC_AHB1PeriphClockCmd</span><span class="token macro property">#<span class="token directive keyword">define</span> LED_B_RCC_AHBxPeriph_GPIOx RCC_AHB1Periph_GPIOC</span><span class="token macro property">#<span class="token directive keyword">define</span> LED_B_GPIOx GPIOC</span><span class="token macro property">#<span class="token directive keyword">define</span> LED_B_GPIO_Pin_x GPIO_Pin_8</span><span class="token macro property">#<span class="token directive keyword">define</span> LED_R_ON GPIO_ResetBits(LED_R_GPIOx, LED_R_GPIO_Pin_x)</span><span class="token macro property">#<span class="token directive keyword">define</span> LED_R_OFF GPIO_SetBits(LED_R_GPIOx, LED_R_GPIO_Pin_x)</span><span class="token macro property">#<span class="token directive keyword">define</span> LED_B_ON GPIO_ResetBits(LED_B_GPIOx, LED_B_GPIO_Pin_x)</span><span class="token macro property">#<span class="token directive keyword">define</span> LED_B_OFF GPIO_SetBits(LED_B_GPIOx, LED_B_GPIO_Pin_x)</span><span class="token macro property">#<span class="token directive keyword">define</span> ONLY_LED_B_ON \    LED_B_ON;         \    LED_R_OFF</span><span class="token macro property">#<span class="token directive keyword">define</span> ONLY_LED_R_ON \    LED_R_ON;         \    LED_B_OFF</span><span class="token macro property">#<span class="token directive keyword">define</span> CLOLOR_LED_ON \    LED_R_ON;         \    LED_B_ON</span><span class="token macro property">#<span class="token directive keyword">define</span> ALL_LED_OFF \    LED_R_OFF;      \    LED_B_OFF</span></code></pre><h2 id="无线调试器连-SWD-接口"><a href="#无线调试器连-SWD-接口" class="headerlink" title="无线调试器连 SWD 接口"></a>无线调试器连 SWD 接口</h2><img src="./2.jpg" width = "200" height = "300" alt="接收端" align=center /><img src="./1.jpg" width = "200" height = "300" alt="接收端" align=center /><p>只需要电脑端 USB 连接发送端,接收端连接板子 SWD 接口(注意线序)，即可正常使用 Keil 下载代码，进入 Debug 模式等等。</p><h2 id="蓝牙-x2F-WIFI-x2F-无线调试器-VOFA"><a href="#蓝牙-x2F-WIFI-x2F-无线调试器-VOFA" class="headerlink" title="蓝牙&#x2F;WIFI&#x2F;无线调试器 + VOFA+"></a>蓝牙&#x2F;WIFI&#x2F;无线调试器 + VOFA+</h2><p>参考以下博客<a href="https://blog.csdn.net/qq_56030168/article/details/124545048#2.2%20justfloat">Vofa+使用笔记（1）：用 Vofa+通过串口连接显示波形</a></p><p>在平衡步兵代码中的 BlueToothTask 中，则是通过以下代码发送需要显示在 VOFA+中的数据。</p><pre class=" language-c"><code class="language-c">        <span class="token comment" spellcheck="true">// 电容功能测试</span>        data<span class="token punctuation">.</span>fdata<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> INA260_1<span class="token punctuation">.</span>Power <span class="token operator">/</span> <span class="token number">1000.0f</span><span class="token punctuation">;</span>        data<span class="token punctuation">.</span>fdata<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> referee_data<span class="token punctuation">.</span>Power_Heat_Data<span class="token punctuation">.</span>chassis_power<span class="token punctuation">;</span>        data<span class="token punctuation">.</span>fdata<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> buffer_energy<span class="token punctuation">.</span>buffering_energy<span class="token punctuation">;</span>        data<span class="token punctuation">.</span>fdata<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> super_power<span class="token punctuation">.</span>actual_vol<span class="token punctuation">;</span>        data<span class="token punctuation">.</span>fdata<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>INA260_1<span class="token punctuation">.</span>Power <span class="token operator">-</span> INA260_2<span class="token punctuation">.</span>Power<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1000.0f</span><span class="token punctuation">;</span>        data<span class="token punctuation">.</span>fdata<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> balance_infantry<span class="token punctuation">.</span>state_vector<span class="token punctuation">[</span>STATE_X_V<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">BLUE_TOOTHSendData</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="掉线检测任务-Offline-task"><a href="#掉线检测任务-Offline-task" class="headerlink" title="掉线检测任务(Offline_task)"></a>掉线检测任务(Offline_task)</h2><p>该任务逻辑比较简单，即通过接受传感器帧数来判断是否有传感器掉线，同时该任务也会对电机保护情况进行观测，若有错误则立即反馈异常，交给其它任务处理该异常。</p><h2 id="电路测试任务-Test-task"><a href="#电路测试任务-Test-task" class="headerlink" title="电路测试任务(Test_task)"></a>电路测试任务(Test_task)</h2><p>给电路测试用的任务，可以测试底盘板 CAN1,CAN2,两个 RS485 接口是否有信号。在平衡步兵代码中，可以通过使 TEST_TASK_ON 为 1 使能测试任务。</p><h2 id="轮毂电机系统辨识任务-MF9025-IdentifyTask"><a href="#轮毂电机系统辨识任务-MF9025-IdentifyTask" class="headerlink" title="轮毂电机系统辨识任务(MF9025_IdentifyTask)"></a>轮毂电机系统辨识任务(MF9025_IdentifyTask)</h2><p>辨识轮毂电机转动惯量的任务,可以通过使 MF9025_IDENTIFY_ON 宏定义为 1 使能该任务，具体可以辨识思路可以参考 《轮腿平衡步兵总结》 - 《功能研发》 - 《轮毂电机参数辨识》</p><h2 id="看门狗设计"><a href="#看门狗设计" class="headerlink" title="看门狗设计"></a>看门狗设计</h2><p>该看门狗只有在所有关键任务都喂狗之后，才算整个系统运行正常而不重启，该目标的实现是通过任务组来实现，即</p><pre class=" language-c"><code class="language-c">        xCreatedEventGroup <span class="token operator">=</span> <span class="token function">xEventGroupCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 创建任务组</span>        <span class="token comment" spellcheck="true">/* 等待所有任务发来事件标志 */</span>        uxBits <span class="token operator">=</span> <span class="token function">xEventGroupWaitBits</span><span class="token punctuation">(</span>xCreatedEventGroup<span class="token punctuation">,</span>           <span class="token comment" spellcheck="true">/* 事件标志组句柄 */</span>                                     TASK_BIT_ALL<span class="token punctuation">,</span>                 <span class="token comment" spellcheck="true">/* 等待TASK_BIT_ALL被设置 */</span>                                     pdTRUE<span class="token punctuation">,</span>                       <span class="token comment" spellcheck="true">/* 退出前TASK_BIT_ALL被清除，这里是TASK_BIT_ALL都被设置才表示“退出”*/</span>                                     pdTRUE<span class="token punctuation">,</span>                       <span class="token comment" spellcheck="true">/* 设置为pdTRUE表示等待TASK_BIT_ALL都被设置*/</span>                                     <span class="token function">pdMS_TO_TICKS</span><span class="token punctuation">(</span>xTicksToWait<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 等待延迟时间 */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>uxBits <span class="token operator">&amp;</span> TASK_BIT_ALL<span class="token punctuation">)</span> <span class="token operator">==</span> TASK_BIT_ALL<span class="token punctuation">)</span>               <span class="token comment" spellcheck="true">// 判断各个任务是否执行</span>        <span class="token punctuation">{</span>            <span class="token function">IWDG_Feed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span></code></pre><p>喂狗则是通过</p><pre class=" language-c"><code class="language-c"> <span class="token comment" spellcheck="true">/*  喂狗 */</span><span class="token function">xEventGroupSetBits</span><span class="token punctuation">(</span>xCreatedEventGroup<span class="token punctuation">,</span> CHASIS_CONTROL_BIT<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 标志位置一</span></code></pre><p>这样的话，只要有一个关键任务没有完成喂狗操作，则整个系统都会重启，从而保障了整个系统的稳定性。</p><h2 id="Jscope"><a href="#Jscope" class="headerlink" title="Jscope"></a>Jscope</h2><p>参考该博客<a href="https://blog.csdn.net/qq_40696002/article/details/107855368">单片机调试工具 J-Scopex 使用说明</a></p><h2 id="Vscode-Ozone-调试"><a href="#Vscode-Ozone-调试" class="headerlink" title="Vscode + Ozone 调试"></a>Vscode + Ozone 调试</h2><p>使用 Vscode 代替 Keil 进行代码编辑有以下几个好处(包括但不限于)</p><ol><li><p>Vscode 界面美观</p></li><li><p>代码提示，代码可自动缩进对齐</p></li><li><p>可通过 Vscode 插件配合提高写代码效率。</p></li></ol><p>详细使用方法可以参考 《轮腿平衡步兵总结》 - 《功能研发》 - 《Ozone+Vscode 嵌入式开发》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;轮腿平衡步兵总结-调试工具篇&quot;&gt;&lt;a href=&quot;#轮腿平衡步兵总结-调试工具篇&quot; class=&quot;headerlink&quot; title=&quot;轮腿平衡步兵总结 - 调试工具篇&quot;&gt;&lt;/a&gt;轮腿平衡步兵总结 - 调试工具篇&lt;/h1&gt;&lt;h2 id=&quot;J-link-RTT&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="RoboMaster" scheme="https://xianmengxi.github.io/categories/RoboMaster/"/>
    
    
    <category term="RoboMaster" scheme="https://xianmengxi.github.io/tags/RoboMaster/"/>
    
    <category term="电控组" scheme="https://xianmengxi.github.io/tags/%E7%94%B5%E6%8E%A7%E7%BB%84/"/>
    
    <category term="代码调试" scheme="https://xianmengxi.github.io/tags/%E4%BB%A3%E7%A0%81%E8%B0%83%E8%AF%95/"/>
    
    <category term="轮腿平衡步兵" scheme="https://xianmengxi.github.io/tags/%E8%BD%AE%E8%85%BF%E5%B9%B3%E8%A1%A1%E6%AD%A5%E5%85%B5/"/>
    
  </entry>
  
  <entry>
    <title>轮腿平衡步兵总结 - 电路设计篇</title>
    <link href="https://xianmengxi.github.io/2023/08/20/lun-tui-ping-heng-bu-bing-zong-jie-dian-lu-she-ji-pian/"/>
    <id>https://xianmengxi.github.io/2023/08/20/lun-tui-ping-heng-bu-bing-zong-jie-dian-lu-she-ji-pian/</id>
    <published>2023-08-20T02:00:00.000Z</published>
    <updated>2023-11-21T12:20:00.088Z</updated>
    
    <content type="html"><![CDATA[<h1 id="轮腿平衡步兵总结-电路设计篇"><a href="#轮腿平衡步兵总结-电路设计篇" class="headerlink" title="轮腿平衡步兵总结 - 电路设计篇"></a>轮腿平衡步兵总结 - 电路设计篇</h1><h2 id="RS485-接口设计"><a href="#RS485-接口设计" class="headerlink" title="RS485 接口设计"></a>RS485 接口设计</h2><p>最初版的 485 电路接口长这样</p><p><img src="/2023/08/20/lun-tui-ping-heng-bu-bing-zong-jie-dian-lu-she-ji-pian/2023-08-20-12-46-32.png"></p><p>修改之后的 485 电路接口长这样</p><p><img src="/2023/08/20/lun-tui-ping-heng-bu-bing-zong-jie-dian-lu-she-ji-pian/2023-08-20-12-47-46.png"></p><p>最初版的电路存在以下几个问题：</p><ol><li><p>原 RS485 通信只包含一个芯片，但宇树 A1 电机只允许同时串联 0-3 个电机，轮腿平衡步兵一共有四个关节电机，故至少需要两路 485 通信接口才可。</p></li><li><p>最初版的 RS485 通信电路只适合于较低的波特率(例如 115200)，在波特率较高时无法正常通信，故驱动不了波特率为 4.8M 的宇树 A1 电机。</p></li></ol><h2 id="电流电压采样接口"><a href="#电流电压采样接口" class="headerlink" title="电流电压采样接口"></a>电流电压采样接口</h2><p><img src="/2023/08/20/lun-tui-ping-heng-bu-bing-zong-jie-dian-lu-she-ji-pian/2023-08-20-13-01-59.png"></p><p>经常性存在 INA260 读不到数据的情况，由于 INA260 反馈信息在功率控制算法中起到至关重要的作用，故若嵌软反馈收不到电流计数据，可以考虑更换一下 INA260 芯片。</p><h2 id="双向电源选择电路"><a href="#双向电源选择电路" class="headerlink" title="双向电源选择电路"></a>双向电源选择电路</h2><p><img src="/2023/08/20/lun-tui-ping-heng-bu-bing-zong-jie-dian-lu-she-ji-pian/2023-08-20-13-02-45.png"></p><p>该电路中，若 MOS 管损坏，则会存在若当前处于电容供电状态(因为 23 赛季平衡步兵使用的是伪被动电容)，因为机器人死亡出现底盘板以及裁判系统供电断电，底盘板对双路电源选择的控制消失，则会出现机器人死亡时仍有电容向轮毂电机供电的情况。这种情况会导致很多问题的发生，比如低电容电压给轮毂电机供电会使其进入低电压保护状态，再比如若死亡时给轮子的力矩不为 0，则在机器人死亡后，由于底盘板控制作用的消失，轮子将会保持原控制力矩而导致机器人“发疯”的情况。赛场上出现了多次 MOS 管损坏的情况，原因未知。</p><h2 id="电容充电模块"><a href="#电容充电模块" class="headerlink" title="电容充电模块"></a>电容充电模块</h2><p><img src="/2023/08/20/lun-tui-ping-heng-bu-bing-zong-jie-dian-lu-she-ji-pian/2023-08-20-13-09-02.png"></p><p>该电路尚存在两个问题</p><ol><li><p>电容电压采样比不够准确，按照该原理图，采样电压*6.8 应该就是电容的实际电压，但实际上会存在很大误差，必须通过万用表测量电压以及观测实际反馈电压来拟合一个较为准确的比例系数，否则反馈电压与实际电压将会存在较大误差。</p></li><li><p>最大充电电流的未知性，芯片最大充电电流为 10A，但若实际以 10A 电流充电，可能会存在较大的安全隐患(比如起火)，目前使用的是最大 5A 充电，尚不知道实际充电电流上限是多少，而且充电电流上限可能会根据板子焊接的不同而不同，故如何压榨干该电容的性能成了一个很大的问题。</p></li></ol><h2 id="TF-卡电路"><a href="#TF-卡电路" class="headerlink" title="TF 卡电路"></a>TF 卡电路</h2><p><img src="/2023/08/20/lun-tui-ping-heng-bu-bing-zong-jie-dian-lu-she-ji-pian/2023-08-20-13-16-29.png"></p><p>因为驱动 SPI 的代码过于复杂而导致很难判断是代码有问题还是电路存在问题，当前代码已调试通过的情况下，若存在问题，可以通过检查焊接情况来判断哪个引脚可能存在虚焊(或者全部重焊)。</p><h2 id="CAN-通信电路"><a href="#CAN-通信电路" class="headerlink" title="CAN 通信电路"></a>CAN 通信电路</h2><p><img src="/2023/08/20/lun-tui-ping-heng-bu-bing-zong-jie-dian-lu-she-ji-pian/2023-08-20-13-20-47.png"></p><p>若同一路 CAN 的负载变大了之后，丢帧问题开始变得十分严重，控制不得不通过降低通信频率来减轻同一路的负载。未来可以考虑更换 CAN 芯片来看看是否能有效增加电路的稳定性。(即使使用屏蔽线之后感觉效果甚微)</p><h2 id="IMU-电路-CAN-版本"><a href="#IMU-电路-CAN-版本" class="headerlink" title="IMU 电路(CAN 版本)"></a>IMU 电路(CAN 版本)</h2><p><img src="/2023/08/20/lun-tui-ping-heng-bu-bing-zong-jie-dian-lu-she-ji-pian/2023-08-20-13-26-27.png"></p><ol><li><p>目前该 IMU 电路的主要思路是通过 SPI 读取 IMU 的信息，然后通过 CAN 发送到底盘控制板完成控制，这实际上存在一个问题就是，这会使 CAN 通信的负载加大，从而影响其它电机之类的稳定性。可以考虑将该 CAN 通信改为串口通信等其它通信方式，或者直接利用底盘板的 SPI 来读取 IMU 的信息(类似 C 板)。</p></li><li><p>为了保证 IMU 的零漂基本不变，需要进行温度控制，但该温度控制尚存在一定问题，例如在将机器人断电之后急剧上电，可能会存在 IMU 温度急剧升高而很难降低的情况(缺乏降温手段)，该问题原因未知，暂时是通过提高 IMU 控制温度的手段来一定情况下缓解该问题。</p></li><li><p>经常性存在读取不到 IMU 芯片信息(ID)的情况，原因未知。</p></li><li><p>不同的 IMU 板子温控效果不一样，有的可以让温度在$\pm 0.1 ℃$上下浮动，有的则只能让温度在$\pm 0.5 ℃$上下浮动；有的 PWM 输出给到最大，温度也升不上去，有的即使不控制温度，温度也升得很快。变化的温度将会使陀螺仪零漂不能准确地估计，控制变得困难。</p></li></ol><h2 id="IMU-电路-串口版本"><a href="#IMU-电路-串口版本" class="headerlink" title="IMU 电路(串口版本)"></a>IMU 电路(串口版本)</h2><p><img src="/2023/08/20/lun-tui-ping-heng-bu-bing-zong-jie-dian-lu-she-ji-pian/2023-08-20-14-05-31.png"></p><ol><li>该串口陀螺仪可能存在“间歇性”出现问题，即可能突然串口就收不到数据了这种情况，十分不稳定，后续还需要对电路进行分析并改进。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;轮腿平衡步兵总结-电路设计篇&quot;&gt;&lt;a href=&quot;#轮腿平衡步兵总结-电路设计篇&quot; class=&quot;headerlink&quot; title=&quot;轮腿平衡步兵总结 - 电路设计篇&quot;&gt;&lt;/a&gt;轮腿平衡步兵总结 - 电路设计篇&lt;/h1&gt;&lt;h2 id=&quot;RS485-接口设计&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="RoboMaster" scheme="https://xianmengxi.github.io/categories/RoboMaster/"/>
    
    
    <category term="RoboMaster" scheme="https://xianmengxi.github.io/tags/RoboMaster/"/>
    
    <category term="电控组" scheme="https://xianmengxi.github.io/tags/%E7%94%B5%E6%8E%A7%E7%BB%84/"/>
    
    <category term="轮腿平衡步兵" scheme="https://xianmengxi.github.io/tags/%E8%BD%AE%E8%85%BF%E5%B9%B3%E8%A1%A1%E6%AD%A5%E5%85%B5/"/>
    
    <category term="电路" scheme="https://xianmengxi.github.io/tags/%E7%94%B5%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>轮腿平衡步兵总结 - 机械设计篇</title>
    <link href="https://xianmengxi.github.io/2023/08/19/lun-tui-ping-heng-bu-bing-zong-jie-ji-jie-she-ji-pian/"/>
    <id>https://xianmengxi.github.io/2023/08/19/lun-tui-ping-heng-bu-bing-zong-jie-ji-jie-she-ji-pian/</id>
    <published>2023-08-19T02:00:00.000Z</published>
    <updated>2023-11-21T12:15:35.927Z</updated>
    
    <content type="html"><![CDATA[<h1 id="轮腿平衡步兵总结-机械设计篇"><a href="#轮腿平衡步兵总结-机械设计篇" class="headerlink" title="轮腿平衡步兵总结 - 机械设计篇"></a>轮腿平衡步兵总结 - 机械设计篇</h1><h2 id="轮子设计"><a href="#轮子设计" class="headerlink" title="轮子设计"></a>轮子设计</h2><p>先看一下不能上场的轮子长什么样</p><img src="./1.jpg" width = "300" height = "200" alt="图片名称" align=center /><p>再来看看能上场的轮子长什么样</p><img src="./2.jpg" width = "300" height = "200" alt="图片名称" align=center /><p>两个图中可以很明显看出区别为能上场的轮子会比较薄，当其踩到大弹丸可以碾压过去，而较宽的轮子则无论如何也过不了大弹丸。</p><p>另一个关键特性是轮子的半径，轮子半径越大，其越野性能越好，但 RM 赛场上需要的越野性能不需要特别高(只需要能踩过大弹丸就行)，故轮子半径可以不需要 11cm 那么大(11cm 是 2023 赛季的数据)，可以不用为了设计大轮子而导致云台设计出现很大的问题。</p><h2 id="铝框防护设计"><a href="#铝框防护设计" class="headerlink" title="铝框防护设计"></a>铝框防护设计</h2><img src="./3.jpg" width = "300" height = "400" alt="图片名称" align=center /><p>外层铝框并不是必要的，但它可以有效防止腿被卡住或者对腿造成很大损伤，故最好加上。其刚度是最为重要的特性，因为需要经常经历碰撞，设计时需要特别注意。</p><h2 id="腿设计"><a href="#腿设计" class="headerlink" title="腿设计"></a>腿设计</h2><img src="./4.jpg" width = "300" height = "200" alt="图片名称" align=center /><img src="./5.jpg" width = "300" height = "200" alt="图片名称" align=center /><p>目前算法对腿的长度以及各腿比例要求并不高，但是 2023 赛季有一个问题，就是装上铝框之后，右侧关节与左侧关节连接处安装方式不同导致摩擦力大小不一样，这将会导致起跳时往一边倾斜。</p><p>电机包装得太过严密，导致电机散热很成问题，这将使电机很容易进入过热保护状态。</p><h2 id="腿上下限位设计"><a href="#腿上下限位设计" class="headerlink" title="腿上下限位设计"></a>腿上下限位设计</h2><img src="./6.jpg" width = "300" height = "200" alt="图片名称" align=center /><p>由于在进行运动学解算时，不只有一个解，为将腿保持在一定范围内，需要限制两侧小腿的角度，防止出现异形腿的情况无法恢复。上下限位共同决定了关节的运动范围，同时上限位作为关节电机初始化的位置，必须保证左右两个小腿在机器人倒下时能够自然收到两个限位处。下限位则决定了起跳或者站立的最大高度。</p><h2 id="倾倒导轮设计"><a href="#倾倒导轮设计" class="headerlink" title="倾倒导轮设计"></a>倾倒导轮设计</h2><img src="./7.jpg" width = "300" height = "200" alt="图片名称" align=center /><img src="./8.jpg" width = "300" height = "200" alt="图片名称" align=center /><p>倾倒角度指的是机器人不受力时自然倾倒时，车身与水平的夹角(如图)，倾角较小时起身功率将会降低很多，但可能会导致上坡时导轮磕到坡，故需要设计到一个合适的角度(2023 赛季为 18 度)。上交通过减小倾角，同时在上坡时让机器人抬腿抬高，这是一个不错的优化思路，可以参考一下。</p><p>该导轮设计时最好不要在装甲板外面，因为如果露出在装甲板外面，将会导致机器人变长，这样下落凤坡时若速度不够，则很容易磕到导轮翻车。(这一点同时也要求车尽量做短一些)。</p><p>该导轮位置也是磕碰重灾区，需要保证刚度。</p><h2 id="NUC-位置设计"><a href="#NUC-位置设计" class="headerlink" title="NUC 位置设计"></a>NUC 位置设计</h2><img src="./9.jpg" width = "300" height = "200" alt="图片名称" align=center /><p>目前 NUC 设计在云台与底盘连接处，这会导致 NUC 散热困难，散出的热量会加剧关节电机的发热。</p><h2 id="Yaw-轴固定设计"><a href="#Yaw-轴固定设计" class="headerlink" title="Yaw 轴固定设计"></a>Yaw 轴固定设计</h2><img src="./11.jpg" width = "300" height = "200" alt="图片名称" align=center /><p>当前(2023 赛季)固定方式十分冗余，使机器人增重明显。</p><h2 id="IMU-位置设计"><a href="#IMU-位置设计" class="headerlink" title="IMU 位置设计"></a>IMU 位置设计</h2><img src="./10.jpg" width = "300" height = "200" alt="图片名称" align=center /><p>IMU 需要放置在如图的位置，但图中由于设计问题，若需要更换 IMU 则需要将底下的整块板子拆掉，十分麻烦，故下一版车需要特别考虑这个问题。</p><h2 id="其它细节问题"><a href="#其它细节问题" class="headerlink" title="其它细节问题"></a>其它细节问题</h2><ol><li><p>在电路完整布完线之后，需要检查一下重心位置，尽量把两边调整到对称位置。</p></li><li><p>减一下重(23 赛季 23kg 左右)，否则起身功率很高以及起跳困难。</p></li><li><p>设计完成之后记得和电路讨论一下布线，尽量让布线阳间一点。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;轮腿平衡步兵总结-机械设计篇&quot;&gt;&lt;a href=&quot;#轮腿平衡步兵总结-机械设计篇&quot; class=&quot;headerlink&quot; title=&quot;轮腿平衡步兵总结 - 机械设计篇&quot;&gt;&lt;/a&gt;轮腿平衡步兵总结 - 机械设计篇&lt;/h1&gt;&lt;h2 id=&quot;轮子设计&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="RoboMaster" scheme="https://xianmengxi.github.io/categories/RoboMaster/"/>
    
    
    <category term="RoboMaster" scheme="https://xianmengxi.github.io/tags/RoboMaster/"/>
    
    <category term="轮腿平衡步兵" scheme="https://xianmengxi.github.io/tags/%E8%BD%AE%E8%85%BF%E5%B9%B3%E8%A1%A1%E6%AD%A5%E5%85%B5/"/>
    
    <category term="机械" scheme="https://xianmengxi.github.io/tags/%E6%9C%BA%E6%A2%B0/"/>
    
    <category term="机械组" scheme="https://xianmengxi.github.io/tags/%E6%9C%BA%E6%A2%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>轮腿平衡步兵总结 - 电机篇</title>
    <link href="https://xianmengxi.github.io/2023/08/19/lun-tui-ping-heng-bu-bing-zong-jie-dian-ji-pian/"/>
    <id>https://xianmengxi.github.io/2023/08/19/lun-tui-ping-heng-bu-bing-zong-jie-dian-ji-pian/</id>
    <published>2023-08-19T02:00:00.000Z</published>
    <updated>2023-11-21T12:22:02.566Z</updated>
    
    <content type="html"><![CDATA[<h1 id="轮腿平衡步兵总结-电机篇"><a href="#轮腿平衡步兵总结-电机篇" class="headerlink" title="轮腿平衡步兵总结 - 电机篇"></a>轮腿平衡步兵总结 - 电机篇</h1><h2 id="两种电机类型"><a href="#两种电机类型" class="headerlink" title="两种电机类型"></a>两种电机类型</h2><h3 id="直驱式电机"><a href="#直驱式电机" class="headerlink" title="直驱式电机"></a>直驱式电机</h3><p>不带减速器的电机，这种电机优点在于编码器较为准确，不用进行减速比换算，故十分适合作为轮毂电机使用。缺点在于输出扭矩一般较小。</p><h3 id="减速电机"><a href="#减速电机" class="headerlink" title="减速电机"></a>减速电机</h3><p>带减速器的电机，优点在于能通过减速器来输出大力矩，缺点在于会降低位置估计精度，同时使输出轴转速下降，适合用于关节处需要较大力矩的地方。</p><h2 id="轮毂电机"><a href="#轮毂电机" class="headerlink" title="轮毂电机"></a>轮毂电机</h2><h3 id="MF9025-电机"><a href="#MF9025-电机" class="headerlink" title="MF9025 电机"></a>MF9025 电机</h3><p>此为大多数学校使用的轮毂电机，电机通讯方式包含 CAN 通信以及 RS485 通信两种，我们使用的是 CAN 通信电机，控制方式选择为力控，线圈匝数为 16 匝。</p><p><img src="/2023/08/19/lun-tui-ping-heng-bu-bing-zong-jie-dian-ji-pian/2023-08-19-15-47-09.png"></p><h4 id="关键参数"><a href="#关键参数" class="headerlink" title="关键参数"></a>关键参数</h4><ul><li>额定电压</li></ul><p>该参数为供电电压，24V 供电电压非常常见，但要注意不要正负极接反，这可能会弄坏电机。</p><ul><li>额定扭矩</li></ul><p>该参数表明了力控时能够正常跟随给定扭矩的范围，也就是说，MF9025 电机再 0 - 2.42 N.M 力范围以内，都能进行准确的力矩跟随(经过测试确实是这样)，但超过 2.42 N.M 力范围之后，发送的电流换算成力矩之后与实际电机反馈力矩不再相等。</p><ul><li>峰值扭矩</li></ul><p>表明了电机输出的最大力矩，根据手册中的通信协议</p><p><img src="/2023/08/19/lun-tui-ping-heng-bu-bing-zong-jie-dian-ji-pian/2023-08-19-16-03-50.png"></p><p>电机发送电流最大值为 32A(注意这里是相电流而非母线电流)，而扭矩常数为 0.32 N.m&#x2F;A，这是否说明如果给电机发送 32A，那么电机输出力矩就是 10.24 N.m 呢？答案是否定的。该扭矩常数进行的换算只在额定扭矩范围以内有效。例如，发送的扭矩(发送的值会通过扭矩常数换算为电流)为 1.5N.m 的话，反馈扭矩也一定是 1.5N.m，但发送的扭矩为 4N.m(经扭矩常数换为电流)的话，反馈扭矩可能是 2.9N.m。发送扭矩为 10N.m 的话，反馈扭矩可能才是 4.5N.m，呈现非线性。故代码中可以按照 10.24N.m 来限制发送扭矩而不是 4.5N.m，将发送扭矩限制在 4.5N.m 可能会出现上不了坡的情况。</p><ul><li>额定转速</li></ul><p>该参数决定了平衡步兵的移动速度，例如 490rpm _ 6.28 &#x2F; 60 (转 rad&#x2F;s) _ 0.11 (轮子半径) &#x3D; 5.64 m&#x2F;s,说明了平衡步兵最大移动速度为 5.64m&#x2F;s，而实际上场的平衡步兵速度最大达到 2.5m&#x2F;s，故该参数完全符合要求。</p><h4 id="上位机关键调整"><a href="#上位机关键调整" class="headerlink" title="上位机关键调整"></a>上位机关键调整</h4><ul><li><p>电机 ID</p></li><li><p>是否选择多电机模式(多电机模式下，有部分电机可能由于固件不是最新导致通信出问题，此时需要找售后拿最新固件更新)</p></li><li><p>最大功率，可以限制最大功率输出，一般保持默认即可</p></li><li><p>最大转速，限制了电机最大转速，可以根据假定平衡步兵最大移动速度设定，防止电机转速过大导致的机器人状态发散。</p></li><li><p>高低电压保护，因为复活赛时存在 MOS 管坏了，导致电容给轮毂电机供电然后电机一直在保护状态的情况，我们把高低电压保护关了，这实际上不好，很容易损坏电机。</p></li></ul><h4 id="电机核心问题"><a href="#电机核心问题" class="headerlink" title="电机核心问题"></a>电机核心问题</h4><ol><li><p>通信问题，首先检查 ID 是否正确，如果在多电机模式下还需要检查一下固件是不是最新的(保证上位机多电机模式开启了)。该电机很容易出现通信丢帧情况(故 2023 赛季都是将两个轮毂电机单独放在一路)。</p></li><li><p>电机高低电压保护问题，事实上，我们在两种情况下遇到了这种问题，第一种是在没有上超级电容时，机器人在跑动过程中突然电机进入保护状态，这时候需要考虑是否是电源管理出了问题，导致电压稳不住。第二种是在上了超级电容之后，超级电容供电下，若电容电压过低，则会让轮毂电机进入保护状态。若必要，下赛季可以改成单电机控制，若发现电机报错了，可以及时发送特定信息消除电机错误状态，提高容错率。</p></li></ol><h2 id="关节电机"><a href="#关节电机" class="headerlink" title="关节电机"></a>关节电机</h2><h3 id="宇树-A1-电机"><a href="#宇树-A1-电机" class="headerlink" title="宇树 A1 电机"></a>宇树 A1 电机</h3><p>该电机为带行星减速器的电机，故可以提供较大力矩，通信方式为 RS485 通信，控制方式为力控。</p><h4 id="关键参数-1"><a href="#关键参数-1" class="headerlink" title="关键参数"></a>关键参数</h4><p><img src="/2023/08/19/lun-tui-ping-heng-bu-bing-zong-jie-dian-ji-pian/2023-08-19-18-36-30.png"></p><ul><li>最大扭矩</li></ul><p>这个是指输出轴上的最大扭矩(电机输出扭矩*减速比)，该最大扭矩表明了代码需要限制的最大扭矩(或者稍小一点)，该值越大，机器人爆发力越强，可以起跳的高度也越高。</p><ul><li>减速比</li></ul><p>该参数表中减速比为 9.0，而使用手册中减速比则为 9.1，实际使用时使用 9.1。编程中，需要将需要的输出轴扭矩除以减速比之后再发送(协议要求)。</p><ul><li>转矩常数</li></ul><p>可以实现从扭矩到电流的转换，注意转换得到的电流值为相电流值而非母线电流值，故不可以直接利用此值作为稳压电流上限的参考。</p><h4 id="上位机关键调整-1"><a href="#上位机关键调整-1" class="headerlink" title="上位机关键调整"></a>上位机关键调整</h4><ol><li><p>电机 ID 修改，可以通过拨动机器人的关节来修改 ID，详细见使用手册。</p></li><li><p>电机基础功能测试</p></li></ol><h4 id="电机核心问题-1"><a href="#电机核心问题-1" class="headerlink" title="电机核心问题"></a>电机核心问题</h4><ol><li><p>关节电机通信要求的波特率为 4.8MHZ，这是一个很高的波特率，若电路接口不稳定，有可能会导致通信不通的情况(目前板子该 485 接口还是没什么问题的)。电机通信中，需要延时一段时间并通过 GPIO 口切换 RS485 的发收(半双工)。手册中的通信协议中，ModifyBit 应该是不要求的，但实际上应该设置为 0xFF,否则可能会有一定的问题。</p></li><li><p>该电机使用的是单圈绝对位置编码器(区别于双编码器)，由于减速比为 1：9,故电机转动一周输出轴只转动了 40 度，这意味着，电机编码器位置不能唯一确认输出轴的位置，这就是为什么平衡步兵初始化时一定要先将腿收到上限位再标定初始化位置的原因。</p></li><li><p>关节电机因为平衡步兵一直站着需要一直堵转输出扭矩，故很容易一直发热，会导致电机温度过高进入电机保护，若反馈信息 MError 不等于 0，则说明进入了电机保护状态，此时需要将电机重新上电才能消除该状态。同时可以通过 Temp 来查看电机的温度，一般 65 度以上就会出现电机保护的情况。</p></li></ol><h3 id="海泰-HT04-电机"><a href="#海泰-HT04-电机" class="headerlink" title="海泰 HT04 电机"></a>海泰 HT04 电机</h3><h3 id="宇树-GO-电机"><a href="#宇树-GO-电机" class="headerlink" title="宇树 GO 电机"></a>宇树 GO 电机</h3><p>根据群里大佬们的描述，宇树 GO 电机主要存在以下问题：</p><ol><li>瞬时大功率会导致电机失控，需要断电重启才行，我们使用的宇树 A1 电机因为两边均连接有稳压故可以避免该问题的出现，但听说 GO 电机不能避免(当前赛季还没测过)。主要原因是大功率会对 RS485 通信产生影响，群里大佬提出的建议是使用官方的 485 模块，便可以避免该问题的出现(需测试过才知道)。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;轮腿平衡步兵总结-电机篇&quot;&gt;&lt;a href=&quot;#轮腿平衡步兵总结-电机篇&quot; class=&quot;headerlink&quot; title=&quot;轮腿平衡步兵总结 - 电机篇&quot;&gt;&lt;/a&gt;轮腿平衡步兵总结 - 电机篇&lt;/h1&gt;&lt;h2 id=&quot;两种电机类型&quot;&gt;&lt;a href=&quot;#两种电</summary>
      
    
    
    
    <category term="RoboMaster" scheme="https://xianmengxi.github.io/categories/RoboMaster/"/>
    
    
    <category term="RoboMaster" scheme="https://xianmengxi.github.io/tags/RoboMaster/"/>
    
    <category term="电控组" scheme="https://xianmengxi.github.io/tags/%E7%94%B5%E6%8E%A7%E7%BB%84/"/>
    
    <category term="轮腿平衡步兵" scheme="https://xianmengxi.github.io/tags/%E8%BD%AE%E8%85%BF%E5%B9%B3%E8%A1%A1%E6%AD%A5%E5%85%B5/"/>
    
    <category term="电机" scheme="https://xianmengxi.github.io/tags/%E7%94%B5%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>使用Vscode + Ozone 替代 keil 进行嵌入式开发</title>
    <link href="https://xianmengxi.github.io/2023/04/20/vscode-ozone-qian-ru-shi-kai-fa/"/>
    <id>https://xianmengxi.github.io/2023/04/20/vscode-ozone-qian-ru-shi-kai-fa/</id>
    <published>2023-04-20T02:00:00.000Z</published>
    <updated>2023-11-21T12:39:21.870Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用Vscode-Ozone-替代-keil-进行嵌入式开发"><a href="#使用Vscode-Ozone-替代-keil-进行嵌入式开发" class="headerlink" title="使用Vscode + Ozone 替代 keil 进行嵌入式开发"></a>使用Vscode + Ozone 替代 keil 进行嵌入式开发</h1><h2 id="Vscode配置"><a href="#Vscode配置" class="headerlink" title="Vscode配置"></a>Vscode配置</h2><p>首先是<a href="https://code.visualstudio.com/Download">vscode下载</a></p><p>安装好之后，点击左侧的扩展安装，搜索C&#x2F;C++并下载(所有的插件均可以通过搜索下载到)</p><p><img src="/2023-03-14-19-26-29.png"></p><p>同理，搜索Keil V,下载该插件</p><p><img src="/2023-03-14-19-29-00.png"></p><p>该插件可以识别Keil工程并且能调用Keil进行编译，但需要先进行以下设置：点击左下方管理，然后点击”设置“，在上方搜索栏中输入Keil,可以发现需要填入Keil中编译器UV4.exe的路径，按照你安装的位置设置即可。</p><p><img src="/2023-03-14-19-30-18.png"></p><p>之后你就可以直接在你工程文件夹的根目录，右击鼠标，选择”通过Code打开“</p><p><img src="/2023-03-14-19-34-03.png"></p><p>之后在vscode中，按ctrl+shift+p，可以出来一个命令框，输入Keil，选择Build target可以对该工程进行编译。</p><p><img src="/2023-03-14-19-35-20.png"></p><p>还有一些好用的插件各位可以按需安装<br>代码格式化:<br><img src="/2023-03-14-19-38-11.png"><br>主题：<br><img src="/2023-03-14-19-38-30.png"><br>彩虹Tab缩进<br><img src="/2023-03-14-19-39-09.png"><br>大括号匹配颜色显示:<br><img src="/2023-03-14-19-39-48.png"></p><p>实际效果示例：<br><img src="/2023-03-14-19-42-14.png"></p><ol><li>只有匹配的大括号颜色是相同的</li><li>彩虹缩进会使代码结构清晰</li><li>能够显示代码提示</li><li>保存文件时会自动进行缩进</li></ol><p><img src="/2023-03-14-19-43-54.png"></p><p>一些tips：</p><ol><li>函数注释写成以下形式，可以很方便地看出各个函数参数的意义(只需要鼠标轻触即可)</li></ol><p><img src="/2023-03-14-19-48-12.png"><br><img src="/2023-03-14-19-48-33.png"></p><ol start="2"><li>ctrl+鼠标点击可以快速函数跳转</li></ol><h2 id="Ozone配置"><a href="#Ozone配置" class="headerlink" title="Ozone配置"></a>Ozone配置</h2><p>首先是<a href="https://www.segger.com/downloads/jlink/">Ozone下载</a>,由于新版的Ozone会提示盗版Jlink然后强行停止你的调试，故尽量选择老版本的Ozone,我选择的是V2.30d(亲测可用),安装包放在同一个压缩包中了。</p><p>打开Ozone,选择芯片型号，选择下载文件的路径，然后打开工程</p><p><img src="/2023-03-14-19-58-56.png"></p><p>打开界面如下图：</p><p><img src="/2023-03-14-20-02-12.png"></p><p>该软件调试功能很多，下面仅仅展示最重要的一种:绘图</p><p><img src="/2023-03-14-20-03-30.png"></p><p>首先在View中打开Data Graph,则下方可以通过输入全局变量的表达式来绘制曲线</p><p><img src="/2023-03-14-20-12-42.png"></p><p><img src="/2023-03-14-20-12-26.png"></p><p>按右键，可以导出为excel格式文件，辅助系统辨识或者其它用途</p><p><img src="/2023-03-14-20-13-30.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;使用Vscode-Ozone-替代-keil-进行嵌入式开发&quot;&gt;&lt;a href=&quot;#使用Vscode-Ozone-替代-keil-进行嵌入式开发&quot; class=&quot;headerlink&quot; title=&quot;使用Vscode + Ozone 替代 keil 进行嵌入式开发</summary>
      
    
    
    
    <category term="RoboMaster" scheme="https://xianmengxi.github.io/categories/RoboMaster/"/>
    
    
    <category term="RoboMaster" scheme="https://xianmengxi.github.io/tags/RoboMaster/"/>
    
    <category term="电控组" scheme="https://xianmengxi.github.io/tags/%E7%94%B5%E6%8E%A7%E7%BB%84/"/>
    
    <category term="代码调试" scheme="https://xianmengxi.github.io/tags/%E4%BB%A3%E7%A0%81%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>PNP深度不确定性导致的拟合轨迹误差影响测定</title>
    <link href="https://xianmengxi.github.io/2022/02/27/pnp-da-fu-shen-du-ce-shi/"/>
    <id>https://xianmengxi.github.io/2022/02/27/pnp-da-fu-shen-du-ce-shi/</id>
    <published>2022-02-27T04:00:00.000Z</published>
    <updated>2023-11-21T12:01:59.661Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PNP深度不确定性对大符轨迹拟合的影响"><a href="#PNP深度不确定性对大符轨迹拟合的影响" class="headerlink" title="PNP深度不确定性对大符轨迹拟合的影响"></a>PNP深度不确定性对大符轨迹拟合的影响</h1><h2 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h2><p>在拟合大符三维运动轨迹的过程之中，需要利用到PNP计算的z轴信息，但是，由于图像处理的不稳定性，装甲板在图像中的位置可能会和真实值偏离1个像素左右，这导致了击打大符的过程z轴距离计算误差特别大(由小孔成像原理)</p><p>以下为使用8mm镜头的计算，具体参考<a href="https://www.jianshu.com/p/83b509953198">能量机关任务参考</a><br><img src="/2022/02/27/pnp-da-fu-shen-du-ce-shi/1.png"></p><p>因为步兵离装甲板中心的x轴距离只有大概0.7m(大符半径),y轴距离也就是1.多米，这是深度的$\frac{1}{8}$,故定位误差大概是2cm以内，这是可以接受的。</p><p>故问题的核心在于PNP的深度误差会对三维圆拟合产生多大的影响，且主要是考察x,y轴的预测(主要要对准位置，高度不对的话可以利用补偿来解决)</p><h2 id="模拟误差测定"><a href="#模拟误差测定" class="headerlink" title="模拟误差测定"></a>模拟误差测定</h2><ul><li><p>首先构造离散点，对x,y轴数据不作噪声处理，z轴数据在8m基础上加上10cm的高斯噪声，以此为基础拟合三维圆</p></li><li><p>参数设置:</p><ol><li>使用多少个数据拟合</li><li>使用多长的数据进行拟合(一个圆的半周或者是$\frac{1}{4}$周)</li></ol></li></ul><p>在此基础上绘制构造的离散点以及拟合的圆</p><p><img src="/2022/02/27/pnp-da-fu-shen-du-ce-shi/2.png"></p><table><thead><tr><th></th><th>Actual</th><th>Curve</th></tr></thead><tbody><tr><td>radius</td><td>0.7</td><td>0.688017</td></tr><tr><td>center</td><td>(0,0,8.0)</td><td>(0.00747922, 0.000957649, 7.99978)</td></tr><tr><td>x_axis</td><td>(0,1,0)</td><td>(-0, 0.99999, 0.00450011)</td></tr><tr><td>y_axis</td><td>(-1,0,0)</td><td>(-0.9988,0.000435318,-0.0489809 )</td></tr></tbody></table><p>利用半周来对圆进行拟合，圆半径设定为0.7m,设定z轴8m为均值，10cm为标准差的高斯噪声</p><p>从结果中发现，对z轴加上噪声之后，所拟合出来的圆形是能够符合基本的精度要求的，这说明了即使PNP精度不够，只要数据足够多，误差分布比较均匀的话，拟合并不会因为此产生很大的偏差，因此初步认为该方案在实际中测试也应该能满足要求。</p><p>问题：如果数据量较少，或者使用的圆转动小于半周的话，拟合出来的圆误差十分大。需要满足精度要求的话就必须加大数据量，这样的话会对拟合速度产生致命的影响</p><h2 id="实际测试过程"><a href="#实际测试过程" class="headerlink" title="实际测试过程"></a>实际测试过程</h2><p>使用80帧对实际PNP数据进行拟合，拟合得到的结果如图</p><p><img src="/2022/02/27/pnp-da-fu-shen-du-ce-shi/3.png"></p><p>切换视图</p><p><img src="/2022/02/27/pnp-da-fu-shen-du-ce-shi/4.png"></p><p>可以看到，拟合实际上比较准确地得到了圆的法向量，但是，由于有一个轴的测量误差抖动过大，导致数据过于离散，实际上很难找到一个合适的轨迹圆</p><p>以下是完整的轨迹与拟合的对比</p><p><img src="/2022/02/27/pnp-da-fu-shen-du-ce-shi/5.png"></p><p><img src="/2022/02/27/pnp-da-fu-shen-du-ce-shi/6.png"></p><ul><li><p>可能的解决方案</p><ol><li><p>直接使用这个拟合圆来处理，由于所得到的法向量实际上是比较正确的，实际击打的方向也应该是正确的，也有可能能够正确击打中目标，不过击打的精度不能够保证</p></li><li><p>换用识别R来进行轨迹预测，利用中心R的好处是能够实时更新轨迹，不至于因为错误的轨迹导致击打失败</p></li><li><p>由于得到了比较正确的法向量，可以将空间中的点投影到与法向量垂直的平面上进行圆拟合，难点是不知道该平面的具体位置(平面的方向已经确定)</p></li></ol></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;PNP深度不确定性对大符轨迹拟合的影响&quot;&gt;&lt;a href=&quot;#PNP深度不确定性对大符轨迹拟合的影响&quot; class=&quot;headerlink&quot; title=&quot;PNP深度不确定性对大符轨迹拟合的影响&quot;&gt;&lt;/a&gt;PNP深度不确定性对大符轨迹拟合的影响&lt;/h1&gt;&lt;h2 i</summary>
      
    
    
    
    <category term="RoboMaster" scheme="https://xianmengxi.github.io/categories/RoboMaster/"/>
    
    
    <category term="RoboMaster" scheme="https://xianmengxi.github.io/tags/RoboMaster/"/>
    
    <category term="算法组" scheme="https://xianmengxi.github.io/tags/%E7%AE%97%E6%B3%95%E7%BB%84/"/>
    
    <category term="大符" scheme="https://xianmengxi.github.io/tags/%E5%A4%A7%E7%AC%A6/"/>
    
    <category term="PNP" scheme="https://xianmengxi.github.io/tags/PNP/"/>
    
  </entry>
  
  <entry>
    <title>2022年美赛总结与反思</title>
    <link href="https://xianmengxi.github.io/2022/02/25/2022-mei-sai-zong-jie-yu-fan-si/"/>
    <id>https://xianmengxi.github.io/2022/02/25/2022-mei-sai-zong-jie-yu-fan-si/</id>
    <published>2022-02-25T02:00:00.000Z</published>
    <updated>2023-11-21T12:02:24.042Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2022年美赛总结与反思"><a href="#2022年美赛总结与反思" class="headerlink" title="2022年美赛总结与反思"></a>2022年美赛总结与反思</h1><p>2022年2月22号早上2点，我们匆匆忙忙地完成了论文，在提交完论文的一刹那，我心中的紧张情绪瞬间得以释放。但是，那一刻，即便我知道这篇论文写得很水，并且能够获奖的概率也微乎其微的情况之下，我仍然没有半点兴奋或者是遗憾。那天晚上我也没有多想，第二天除了比往常要更困一点，也并没有什么不同。</p><p>也许，我并不属于那里。或者说，我的心根本就不在那里。会报名美赛，很单纯就是因为这个比赛容易获奖并且获奖之后能够对自己的保研加分有帮助而已。也正是这个原因，这个比赛的过程使我很痛苦。哪怕是在模型完成的那一刻，我也没有感到兴奋。因为，我清楚地知道，我不过是在做一件自己不喜欢的事情罢了。</p><hr><h2 id="比赛准备与个人理解"><a href="#比赛准备与个人理解" class="headerlink" title="比赛准备与个人理解"></a>比赛准备与个人理解</h2><p>我们的队伍在前期并没有做好充分的准备，我们三个人都没有参加数学建模的经历，因此都对数学建模的整个流程都十分模糊。选择c题的理由也不过是因为所有题目对于我们来说都没有什么不同而已。</p><p>在寒假之前，我就已经抽空学习了司守奎老师的《数学建模与应用》，了解了基本的建模方法以及数据分析方法。但是，数学并不是一天两天就能掌握的，在缺乏练习的情况之下(基本没有打过代码，或者独立推导公式)，我感觉对这些知识的掌握很飘，其实说白了就是没学懂。但是，为了掌握整个知识框架(我一直认为掌握了整个框架之后，学习一些框架之内的内容就是水到渠成的事情)，我也只能硬着头皮学了下去，结果到头来什么也没学好。</p><p>不过，在后来的备赛过程中，我发现，大多数书本里的算法都是用不上的。而且，数学建模里体现的不是你对这个算法的理解，而是你对这个算法的运用。换言之，你不需要理解算法内部的运行机制，你只需要知道，你这么用就能达到你的目的，你只需要使用别人写好的算法接口直接调用就行。当然我也知道在四天之内独立构造自己的模型并且写好代码这件事本身就是强人所难，但是，如果只是了解算法怎么用而不去了解算法的本质的话，那么数学建模就可能变成很多人对算法的”堆砌“比赛，而不能起到帮助我们理解算法本质并实现创新。</p><hr><h2 id="比赛过程"><a href="#比赛过程" class="headerlink" title="比赛过程"></a>比赛过程</h2><p>比赛第一天，我和建模的队友意见产生了分歧。我觉得应该使用时间序列预测+动态规划来求解，而队友觉得应该使用主成分分析的办法。最后我们采用了我的模型。</p><p>比赛第二天，我写好了动态规划的代码，但是，由于预测的不准确(实则上股市不可能做到预测准确会有不确定的白噪声)，加上评分函数的不确定(我个人的能力有限)，迟迟不能将模型建好。这时候，我已经在反思，动态规划是不是行不通？但是，我比较头铁，毕竟都干了一整天了，不能让自己的努力白费，然后又疯狂构建评价函数，最后都失败了。那一天，我几乎毫无进展。</p><p>比赛第三天，我仍然不死心，又干了一个上午，仍然没有构造出来。这才彻底死心。并且，在漫长的查资料过程之中，我看到了很多关于动态规划，神经网络对股市无效的论文，更加坚定了我修改模型的决心。在那个时候，比赛都快结束了，模型还没建立好，我怎么给整个队伍一个交代？我记得当时压力特别大，想着如果那天不能建立模型，那么这次比赛就玩完了。即便是如此，我也告诉自己，必须静下心来学习一些简单的”量化交易策略“(实际上量化交易策略经过社会实践的检验，比你在一两天想到的算法要更优)，于是找到了双均线策略等等的基础策略与代码。为了强制让模型看起来丰满一点又强制加上了唐其安通道，上下止损策略等等来做”组合规划“等等(即便我觉得不是很合理，不过在当时时间紧急状况之下只能胡言乱语了）。那天晚上11点，我才完成了模型，并且画出了几幅颜值比较低的图。模型建立也算不怎么体面地完成了。</p><p>比赛第四天，1-8节课要上课，我没有逃课或者请假，老老实实地听课(虽然没听进去几句就是了)。然后下午六点的时候，开始了肝论文。那时候我们的意见出现了一点分歧，我想用latex排版，但是队友觉得应该使用word排版，他们之前写的一部分论文也是用word排版的。我觉得latex排版本身就比较方便了，而且那时候我也没想到做完一整篇论文需要花费大量的精力,所以我就提议我来排版，他们来将每一个模块写好(如果再来一次，我一定不坚持用latex了，因为当时只有我会用latex(其实我也是现学的)，导致后期工作交接都比较困难)。我们在八小时内肝完了论文，完成得匆匆忙忙，也没有回看一遍论文，草草提交了论文。</p><hr><h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><p>记录心态爆炸的两次：第一次是第二天晚上发现整天都没有成果的时候，焦虑怎样才能建好模型。第二次是第四天晚上写论文的时候，因为眼睛看电脑的时间长了(酸痛)，实在看不下去了，但是因为只有我用latex(自己的埋下的坑自己填)，也不能交接，导致那个时候心态有点爆炸。</p><p>跟队友沟通不好也是这次比赛一个很突出的问题，因为模型是我构建的，但是，对模型内容的书写是交给队友来做的，这就导致了，我建模的想法和队友所写的东西不是很契合(这个应该提前跟他们说明)。而且我们的任务分工不是很明确，导致最后拼成论文的时候还有没有写的部分，在那个每个人都迫切想要下班的时候，还需要加班最为致命。</p><p>我们虽然基本完成了任务的问题，但是，在写论文的过程之中，我发现，我们的论文基本没有对算法给出精度分析或者其它的指标分析，我认为这样是十分不合理且不完善的，算法的结果也难以令人信服。</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>十分感谢两位队友的付出，哪怕最后获不了奖，这也会是我们大学生活的一段独特的经历。在这个过程中，每个人都尽职尽责地完成了自己地任务，我觉得这样就已经足够了。</p><p>这对于我来说是一段难忘的经历，虽然不是很美妙就是了。</p><p>下一年不知道要不要继续参赛，也许会因为觉得枯燥而放弃参赛，也许会因为想要再拼一拼而再来一年，未来的事，谁知道呢？</p><p>我一直想要追寻自己喜欢的东西。我拼命地学习知识，不过是为了能够用知识照亮自己的未来。</p><p>无论如何，美赛已经落下帷幕，未来的路还很长，时间一刻也不会为我而停，我必须收拾包袱，前往更浩瀚的星辰大海。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;2022年美赛总结与反思&quot;&gt;&lt;a href=&quot;#2022年美赛总结与反思&quot; class=&quot;headerlink&quot; title=&quot;2022年美赛总结与反思&quot;&gt;&lt;/a&gt;2022年美赛总结与反思&lt;/h1&gt;&lt;p&gt;2022年2月22号早上2点，我们匆匆忙忙地完成了论文，在提</summary>
      
    
    
    
    <category term="美赛" scheme="https://xianmengxi.github.io/categories/%E7%BE%8E%E8%B5%9B/"/>
    
    
    <category term="美赛" scheme="https://xianmengxi.github.io/tags/%E7%BE%8E%E8%B5%9B/"/>
    
    <category term="数学建模" scheme="https://xianmengxi.github.io/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
    <category term="感悟" scheme="https://xianmengxi.github.io/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>多线程资源共享</title>
    <link href="https://xianmengxi.github.io/2022/02/24/xian-cheng-zi-yuan-gong-xiang/"/>
    <id>https://xianmengxi.github.io/2022/02/24/xian-cheng-zi-yuan-gong-xiang/</id>
    <published>2022-02-24T02:00:00.000Z</published>
    <updated>2023-11-21T12:02:14.706Z</updated>
    
    <content type="html"><![CDATA[<h1 id="c-线程资源共享"><a href="#c-线程资源共享" class="headerlink" title="c++线程资源共享"></a>c++线程资源共享</h1><p>我们知道，在多线程中，如果两个线程都使用到了同一份资源，那么这两个线程对资源修改和使用的先后顺序是不确定的。</p><p>比如有一副1024*1280的图像，一个线程需要不断地更新图像，另一个线程需要使用这个图像并且将其显示出来。如果修改图像的线程运行到一半的时候，显示图像的线程就将数据提取出来显示，那么就可能产生图像残缺的现象。这会对我们的应用产生不可预测的结果。这种线程相互争夺资源的现象，被称为线程不安全。</p><p>要想安全地使用资源，那么就必须设计一定的规则，使得到资源的线程处理；没有得到资源的线程休眠，以此达到线程安全和充分利用cpu的目的。</p><hr><h2 id="使用互斥锁mutex"><a href="#使用互斥锁mutex" class="headerlink" title="使用互斥锁mutex"></a>使用互斥锁mutex</h2><p><a href="https://qingcms.gitee.io/cppreference/20210212/zh/cpp/thread/mutex.html">c++ mutex使用手册</a></p><p>基础用法：</p><pre class=" language-cpp"><code class="language-cpp">    std<span class="token operator">::</span>mutex your_mutex<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//定义你的锁</span>    your_mutex<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//上锁</span>    <span class="token comment" spellcheck="true">//使用你的资源</span>    your_mutex<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre><p>注意同一份资源应该使用同一个锁</p><p>当一个线程调用这个锁对象的lock()函数之后，如果第二个线程也调用了lock函数，那么第二个线程就会”被迫等待”，类似于进入一个while循环，直到第一个线程调用unlock()函数。</p><p>使用互斥锁之后，就能保证每一个时刻都最多只有一个线程在处理这份资源。</p><p>mutex的缺点：等待资源的线程会频繁唤醒cpu，导致程序的性能下降。</p><hr><h2 id="条件变量-智能锁"><a href="#条件变量-智能锁" class="headerlink" title="条件变量+智能锁"></a>条件变量+智能锁</h2><p><a href="https://www.apiref.com/cpp-zh/cpp/thread/condition_variable.html">c++ 条件变量使用手册</a></p><p><a href="https://www.apiref.com/cpp-zh/cpp/thread/unique_lock.html">c++ unique_lock使用手册</a></p><p>使用互斥锁可能会造成死锁的情况，即上锁之后忘记解锁，导致资源一直不能释放，等待资源的线程卡死。</p><p>使用互斥锁导致频繁唤醒cpu会导致性能消耗极大。</p><p>使用条件变量和智能锁能一定程度上解决这些问题</p><p>使用智能锁unique_lock能够在这把锁的声明周期过后自动释放，故避免了死锁的问题</p><p>使用条件变量，当生产者生产完之后，给消费者一个信号，消费者才可以进行处理，否则的话，消费者会一直休眠。使用这种方法，降低了唤醒cpu的频率。导致程序的性能提高。</p><p>有了条件变量还需要使用锁的原因是条件变量可能会误唤醒，加锁是第二层保障</p><p>基本使用(生产者)</p><pre class=" language-cpp"><code class="language-cpp">    std<span class="token operator">::</span>condition_variable cond<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//cond为线程之间共享的变量</span>    <span class="token punctuation">{</span>        std<span class="token operator">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">></span> my_lock<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//生产资源</span>        cond<span class="token punctuation">.</span><span class="token function">notify_one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//唤醒等待的线程</span>    <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//过了unique_lock的生命周期之后，锁自动释放</span></code></pre><pre class=" language-cpp"><code class="language-cpp">    std<span class="token operator">::</span>condition_variable cond<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//cond为线程之间共享的变量</span>    <span class="token punctuation">{</span>        std<span class="token operator">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">></span> my_lock<span class="token punctuation">;</span>        cond<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//等待资源</span>        <span class="token comment" spellcheck="true">//消费资源</span>    <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//过了unique_lock的生命周期之后，锁自动释放</span></code></pre><p>条件变量和智能锁一定程度上提高了程序的性能，但由于还带锁，锁造成的低性能仍然没有发生本质上的改变。如果要使程序处于无锁的良好环境，减少数据竞争的话，需要使用到原子变量的无锁编程。</p><hr><h2 id="无锁循环队列"><a href="#无锁循环队列" class="headerlink" title="无锁循环队列"></a>无锁循环队列</h2><p><a href="https://www.apiref.com/cpp-zh/cpp/atomic/atomic.html">c++ atomic使用手册</a></p><p>要很好地理解以下的代码，就先要了解原子变量内存模型。某个语句f中的一个变量a在下面代码有依赖的意思是下面某句代码g直接或者间接用到了变量a,故编译器会自动将g代码语句放在f后面。否则的话编译器可以自动安排语句的执行顺序，来提高代码的运行效率。</p><p>以下代码适用于生产者-消费者模型</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">ifndef</span> _LOCKFREE_QUEUE_</span><span class="token macro property">#<span class="token directive keyword">define</span> _LOCKFREE_QUEUE_</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;atomic></span>   </span><span class="token comment" spellcheck="true">//原子标准库</span><span class="token macro property">#<span class="token directive keyword">define</span> FIXED_NUM 16 </span><span class="token comment" spellcheck="true">//设置为2的整数次方 方便处理，因为对2的整数次方作除法可以用左移表示</span>    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span> <span class="token comment" spellcheck="true">//模板类，T为你需要共享的数据类型</span>    <span class="token keyword">class</span> <span class="token class-name">LockFreeQueue</span>    <span class="token punctuation">{</span>        <span class="token keyword">struct</span> Element        <span class="token punctuation">{</span>            T data_<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//数据存储区</span>            std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> is_full<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//是否有数据</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token function">LockFreeQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">~</span><span class="token function">LockFreeQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">bool</span> <span class="token function">push</span><span class="token punctuation">(</span>T <span class="token operator">&amp;</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//入栈</span>        <span class="token keyword">bool</span> <span class="token function">pop</span><span class="token punctuation">(</span>T <span class="token operator">&amp;</span>output<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//出栈</span>        std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">short</span><span class="token operator">></span> write_index<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//写索引</span>        Element data_queue<span class="token punctuation">[</span>FIXED_NUM<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//固定大小的数组，通过write_index构成循环队列的效果</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>    LockFreeQueue<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">LockFreeQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        write_index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//初始化为0</span>    <span class="token punctuation">}</span>    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>    LockFreeQueue<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token operator">~</span><span class="token function">LockFreeQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>    <span class="token keyword">bool</span> LockFreeQueue<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">push</span><span class="token punctuation">(</span>T <span class="token operator">&amp;</span>input<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//由于后面的语句都对write_index_temp有依赖，故此处的内存模型可以忽略，或者说用什么都行</span>        <span class="token keyword">short</span> write_index_temp <span class="token operator">=</span> write_index<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token operator">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span>        data_queue<span class="token punctuation">[</span>write_index_temp<span class="token punctuation">]</span><span class="token punctuation">.</span>data_ <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//利用std::move可以加快处理速度，移动过后的对象input不再可用</span>        <span class="token comment" spellcheck="true">//memory_order_release内存模型强制前一条语句在这一条之前运行，即必须要修改完data_再将is_full置true</span>        data_queue<span class="token punctuation">[</span>write_index_temp<span class="token punctuation">]</span><span class="token punctuation">.</span>is_full<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> std<span class="token operator">::</span>memory_order<span class="token operator">::</span>memory_order_release<span class="token punctuation">)</span><span class="token punctuation">;</span>        write_index_temp<span class="token operator">++</span><span class="token punctuation">;</span>         write_index_temp <span class="token operator">%</span><span class="token operator">=</span> FIXED_NUM<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//构成循环</span>        <span class="token comment" spellcheck="true">//强制使write_index_temp修改后再运行，但其实由于write_index_temp用到了write_index_temp,故即使不用memory_order_release模型，也会在write_index_temp自增之后运行</span>        write_index<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span>write_index_temp<span class="token punctuation">,</span> std<span class="token operator">::</span>memory_order<span class="token operator">::</span>memory_order_release<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>    <span class="token keyword">bool</span> LockFreeQueue<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">pop</span><span class="token punctuation">(</span>T <span class="token operator">&amp;</span>output<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//索引到读取index的前一个，更好地达到同步的效果</span>        <span class="token keyword">short</span> read_index <span class="token operator">=</span> write_index<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token operator">::</span>memory_order<span class="token operator">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span>        read_index <span class="token operator">=</span> <span class="token punctuation">(</span>read_index <span class="token operator">+</span> FIXED_NUM <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> FIXED_NUM<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//强制后面的语句在这一条语句之后运行,即必须要is_full为true才执行后面的代码</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>data_queue<span class="token punctuation">[</span>read_index<span class="token punctuation">]</span><span class="token punctuation">.</span>is_full<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token operator">::</span>memory_order_acquire<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            output <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>data_queue<span class="token punctuation">[</span>read_index<span class="token punctuation">]</span><span class="token punctuation">.</span>data_<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//强制前面的代码在这句代码之前执行</span>            data_queue<span class="token punctuation">[</span>read_index<span class="token punctuation">]</span><span class="token punctuation">.</span>is_full<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> std<span class="token operator">::</span>memory_order<span class="token operator">::</span>memory_order_release<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token macro property">#<span class="token directive keyword">endif</span></span></code></pre><p>使用以上代码，当生产资源时，使用push函数；当消费资源时，使用pop函数</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;c-线程资源共享&quot;&gt;&lt;a href=&quot;#c-线程资源共享&quot; class=&quot;headerlink&quot; title=&quot;c++线程资源共享&quot;&gt;&lt;/a&gt;c++线程资源共享&lt;/h1&gt;&lt;p&gt;我们知道，在多线程中，如果两个线程都使用到了同一份资源，那么这两个线程对资源修改和使用的</summary>
      
    
    
    
    <category term="RoboMaster" scheme="https://xianmengxi.github.io/categories/RoboMaster/"/>
    
    
    <category term="RoboMaster" scheme="https://xianmengxi.github.io/tags/RoboMaster/"/>
    
    <category term="算法组" scheme="https://xianmengxi.github.io/tags/%E7%AE%97%E6%B3%95%E7%BB%84/"/>
    
    <category term="c++" scheme="https://xianmengxi.github.io/tags/c/"/>
    
    <category term="多线程" scheme="https://xianmengxi.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>数学建模与应用总结</title>
    <link href="https://xianmengxi.github.io/2022/02/16/shu-xue-jian-mo-yu-ying-yong-zong-jie/"/>
    <id>https://xianmengxi.github.io/2022/02/16/shu-xue-jian-mo-yu-ying-yong-zong-jie/</id>
    <published>2022-02-16T02:00:00.000Z</published>
    <updated>2023-11-21T12:02:18.557Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数学建模算法与应用算法分类与总结"><a href="#数学建模算法与应用算法分类与总结" class="headerlink" title="数学建模算法与应用算法分类与总结"></a>数学建模算法与应用算法分类与总结</h1><h2 id="模型建立方法以及流程"><a href="#模型建立方法以及流程" class="headerlink" title="模型建立方法以及流程"></a>模型建立方法以及流程</h2><ol><li><p>问题分析</p><p>简述问题的意思，明确问题处理的思路</p></li><li><p>模型假设</p><p>通常为8-10条，给出模型在什么条件下成立</p></li><li><p>符号说明</p></li><li><p>模型建立</p><p> 给出一定的公式，推到出相应的最终表达式</p></li><li><p>模型求解</p></li><li><p>灵敏度分析</p><p> 已经假设固定的变量，实际上并不是固定的，要给定其一定的上下波动范围来对其进行求解</p></li><li><p>结果分析以及得出结论</p></li></ol><h2 id="规划类"><a href="#规划类" class="headerlink" title="规划类"></a>规划类</h2><ul><li><p>线性规划</p><ul><li><p>线性规划模型通常在题目中表现会比较明显,不过多赘述(书本$P_1$)</p></li><li><p>可转为线性规划的形式(书本$P_8$)</p></li></ul><p>  $$ \min \lvert x_1 \rvert + \lvert x_2 \rvert +\lvert x_3 \rvert + … + \lvert x_n \rvert \<br>  s.t. Ax \leq b<br>  $$</p><ul><li><p>带有绝对值的min max类非线性规划，可以使用手工线性化之后使用软件求解(书本$P_9$)</p></li><li><p>线性求解参考代码$P_{14}$</p></li></ul></li><li><p>整数规划</p><ul><li><p>适宜解决的问题</p><ol><li><p>符合线性规划的形式且带整数约束的规划问题</p></li><li><p>要么是1要么是0的0-1规划问题(使用或不使用)</p></li><li><p>路线规划问题(也用于图论)，即进入一个地方则$x_{ij}&#x3D;1$,否则$x_{ij}&#x3D;0$ ($P_{20}$)</p></li><li><p>引入充分大的数构成约束来达到选择的效果($P_{21}$)</p></li><li><p>混合整数规划问题，比如如果不采用a方案，那么a方案的产出$x_a&#x3D;0$,这时候可以使用($P_{22}$)</p></li></ol></li><li><p>代码参考$P_{26}$</p></li><li><p>利用蒙卡特洛方法可以很好地对非线性整数规划问题进行求解($P_{27}$)</p></li></ul></li><li><p>非线性规划</p><ul><li><p>无约束非线性优化的求解($P_{38}$),利用海塞尔矩阵求解</p></li><li><p>带约束非线性优化的求解思路，通常是线性化为非线性,带约束化为无约束</p><ol><li><p>只有等式约束的时候，可以采用拉格朗日乘数法($P_{39}$)</p></li><li><p>当同时含有等式约束和不等式约束时，可以采用罚函数法($P_{39}$)</p></li></ol></li><li><p>凸规划($P_{40}$)</p><ul><li><p>凸规划是求解式子为凸函数，不等式约束为凸函数，等式约束为线性函数的规划，线性规划是特殊的凸规划,凸规划局部最优解即为全局最优解</p></li><li><p>KT条件用来判断凸规划的解x是否是全局最优解</p></li></ul></li><li><p>例子($P_{42} , P_{56}$)</p></li><li><p>二次规划</p><ul><li>决策变量为二次函数，而约束条件为线性函数的模型(P_{48})</li></ul></li><li><p>非线性规划代码介绍($P_{49}$)</p></li></ul></li></ul><h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2><ul><li><p>Matlab生成图($P_{65}$)</p></li><li><p>典型的寻路算法(Dijkstra,Floyd)($P_{67}$)</p></li><li><p>最短路问题的0-1整数规划模型，见整数规划($P_{74}$)</p></li><li><p>最小生成树算法($P_{75}$)Prim,Kruskal算法，最小生成树的整数规划模型($P_{78}$)</p></li><li><p>最大流算法:所谓最大流算法指的是在流进等于流出的条件之下，整个图允许通过的最大容量(不包含始末),最大流算法可以写作整数规划模型来求解($P_{82}$),也可以使用标号法Ford-Fulkerson算法来实现($P_{83}$)</p></li><li><p>最小费用流算法：考虑到达终点所需要的最小花费的算法，一般和最大流算法一起使用，一般转化为线性规划来求解，也可以使用迭代法来求解($P_{84}$)</p></li><li><p>改良圈算法：即不重复经过同一个节点，且使得总路程最短的解算算法($P_{88}$)，这个问题也可以用整数规划模型来解决</p></li><li><p>关键路径求解：可以将关键路径看成最长路径来进行求解$P_{96}$，也可以根据最早开工时间和最晚开工时间迭代求解$P_{97}$</p></li><li><p>实际上工作时间可能会随着客观因素而变动，利用$P_{100}$的算法来计算能够按时完成任务的概率</p></li></ul><h2 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h2><ul><li><p>特性：插值可以对区间之外的部分作出短期预测，长期预测可能失效较为严重</p></li><li><p>多项式插值($P_{114}$)</p><ul><li><p>待定系数法，用于观测点数目和约束方程数量一致的情况($P_{114}$) </p></li><li><p>拉格朗日插值法，一般实际应用意义不是很大($P_{115}$)   </p></li><li><p>牛顿插值法，一般实际应用意义不大($P_{116}$)</p></li></ul></li><li><p>分段线性化方法插值，多项式高次插值导致产生龙格震荡现象，故利用分段线性化可以更好地拟合出真正地曲线($P_{119}$)</p></li><li><p>三次样条插值：分段线性化的插值会导致取样点处的导数不存在,三次插值实际上是利用节点处的一阶和二阶导数相等来待定系数求解($P_{119}$)</p></li><li><p>二次插值</p><ul><li><p>网格节点插值法($P_{121}$)</p><ul><li><p>最临近点插值，即某一点与这一点所处于的区间最接近的有值的一点函数值相同</p></li><li><p>分片线性插值</p></li><li><p>双线性插值</p></li></ul></li><li><p>散乱数据插值方法，对一群离散点进行插值($P_{122}$)</p></li></ul></li></ul><h2 id="拟合"><a href="#拟合" class="headerlink" title="拟合"></a>拟合</h2><ul><li><p>最小二乘法拟合(线性与非线性)($P_{132}$)</p></li><li><p>拟合函数选择($P_{133}$)</p></li><li><p>拟合可以使用Matlab工具箱，参考($P_{133}$)</p></li><li><p>曲线与曲面拟合($P_{141}$)</p></li><li><p>拟合或统计的判断方法($P_{143}$)</p></li><li><p>函数逼近($P_{143}$)</p></li></ul><h2 id="微分方程"><a href="#微分方程" class="headerlink" title="微分方程"></a>微分方程</h2><ul><li><p>用途：可用于每一时刻的状态变化和下一时刻状态变化密切相关的场合，比如传染病模型，传染人数和感染人数相关</p></li><li><p>传播可以采用指数传播模型($P_{153}$)</p></li><li><p>三种典型的传染病模型($P_{154}$)</p><ul><li><p>SI模型，不考虑治愈以及免疫</p></li><li><p>SIS模型考虑病人治愈</p></li><li><p>SIR模型考虑治愈以及免疫之后退出感染系统</p></li></ul></li><li><p>微分方程求解($P_{159}$)</p></li><li><p>Lorenz模型的混沌效应:具有初值敏感性(不知道有什么用)($P_{161}$)</p></li><li><p>边值问题求解($P_{166}$)</p></li><li><p>人口预测模型</p><ul><li><p>Malthus模型，人口预测模型，假设人口的增长率不变($P_{170}$)</p></li><li><p>Logistic模型，人口的增长率是与人口数量有关($P_{171}$)</p></li></ul></li><li><p>种群相互作用模型</p><ul><li><p>种群竞争模型($P_{173}$)</p></li><li><p>弱肉强食模型($P_{174}$)</p></li></ul></li></ul><h2 id="数理统计"><a href="#数理统计" class="headerlink" title="数理统计"></a>数理统计</h2><ul><li><p>区间估计:即估计在某一区间内的数占总量的百分之几，注意均值和方差是否已知($P_{182}$)</p></li><li><p>双变量联合分布求置信区间示例($P_{184}$)</p></li><li><p>经验分布函数的使用($P_{184}$)</p></li><li><p>Q-Q图检验拟合优度，即检验某个随机变量是否符合你所预估的分布($P_{185}$)</p></li><li><p>非参数检验</p><ul><li><p>卡方拟合优度检验：检验总体X是否满足某个概率密度($P_{187}$)</p></li><li><p>柯尔莫哥洛夫检验：基于经验分布函数检验理论分布函数与样本分布函数的拟合优度($P_{191}$)</p></li><li><p>秩和检验：检验两个分布总体分布是否有明显差异($P_{192}$)</p></li></ul></li><li><p>Bootstrap方法：抽取很多个样本，利用样本对总体进行统计推断</p><ul><li><p>标准误差的Bootstrap估计($P_{194}$)</p></li><li><p>均方误差的Bootstrap估计($P_{196}$)</p></li><li><p>Bootstrap求解置信区间($P_{197}$)</p></li><li><p>分布函数形式已知，但部分参数未知，可以利用Bootstrap进行参数估计($P_{198}$)</p></li></ul></li><li><p>均值检验：比较两个总体的均值($P_{201}$),不用于多于两个总体</p></li><li><p>单因素方差分析：仅仅考虑一个因素，其它因素不变，用来判断该因素对总体的影响($P_{202}$)</p></li><li><p>双因素方差分析：考虑两个因素对总体的影响，包括无交互影响的双因素方差分析($P_{207}$)和有交互影响的方差分析($P_{208}$)</p></li><li><p>回归分析</p><ul><li><p>多元线性回归</p><ul><li><p>参数估计($P_{211}$)</p></li><li><p>对统计变量的残差，期望，方差进行分析($P_{212}$)</p></li><li><p>回归模型的假设检验,检验变量是否符合该多元线性关系，排除多出维度参数的可能($P_{213}$)</p></li><li><p>回归系数的假设检验和区间估计，即排除部分维度，找出拟合最好的维度，舍去贡献度很小的维度($P_{213}$)</p></li><li><p>回归模型预测($P_{214}$)</p></li></ul></li><li><p>多元二次项回归($P_{214}$)</p></li><li><p>非线性回归($P_{218}$)</p></li><li><p>逐步回归：多因素，使用关联性强的因素选入模型进行回归，舍去关联性不强的因素</p><ul><li><p>前进法，每次增加一个因素，然后使用显著性P值来检验新因素的影响($P_{220}$)</p></li><li><p>后退法，每次减少一个因素，然后使用显著性P值来检验新因素的影响($P_{221}$)</p></li><li><p>逐步回归法，每增加一个因素，就要对所有因素进行一次检验，解得的集合为最优回归子集($P_{221}$)</p></li></ul></li></ul></li><li><p>灰色模型和Bootstrap理论</p><ul><li><p>用途：小样本，数据预测，统计推断，对分布参数进行较为精确的区间估计，不需要知道原有数据的分布($P_{222}$)</p></li><li><p>灰色模型建立($P_{223}$)</p></li><li><p>Bootstrap分析：重发取样，求得统计量的经验分布并进行区间估计($P_{224}$)</p></li></ul></li></ul><h2 id="差分方程"><a href="#差分方程" class="headerlink" title="差分方程"></a>差分方程</h2><ul><li><p>特点：通过递推关系求得状态之间的关联</p></li><li><p>差分方程建模($P_{231}$)</p></li><li><p>Leslie种群模型：求年龄分布和种群增长的规律，有明显的递推关系特征</p></li></ul><h2 id="分类问题"><a href="#分类问题" class="headerlink" title="分类问题"></a>分类问题</h2><ul><li><p>支持向量机($P_{248}$)</p></li><li><p>Q型据类分析($P_{262}$)，对样本进行分类</p></li></ul><h2 id="多元分析"><a href="#多元分析" class="headerlink" title="多元分析"></a>多元分析</h2><ul><li><p>聚类分析</p><ul><li><p>Q型聚类分析，样本分类</p></li><li><p>R型聚类，用于变量分类，便于理清变量之间的关系，然后通过这个关系来选择关键因素进行模型建立($P_{269}$)</p></li></ul></li><li><p>主成分分析($P_{279}$)</p><ul><li><p>特点：是一种降维方法，去除很多无关的变量，提取主要变量</p></li><li><p>主成分回归分析：将回归自变量变换到另一组变量，提取主成分之后再进行逆变换之后得出参数估计</p></li></ul></li><li><p>因子分析：和主成分分析的目的相同，都是特征降维($P_{285}$)</p></li><li><p>因子分析与主成分分析对比($P_{296}$)</p></li><li><p>判别分析：使用研究个体的观察指标来判断个体的类型($P_{303}$)</p><ul><li><p>距离判断($P_{304}$)</p></li><li><p>Fisher判别($P_{306}$)</p></li><li><p>Bayes判别($P_{307}$)</p></li></ul></li><li><p>典型相关分析：用来研究两组变量的相关关系($P_{313}$)</p></li><li><p>对应分析：再因子分析的基础之上，解决因子分析求解速度很慢的问题($P_{328}$)</p></li><li><p>多维标度法：n个指标反映的东西是模糊的，通过这几个指标的距离，反映他们之间的关系($P_{344}$)</p></li></ul><h2 id="偏最小二乘回归分析"><a href="#偏最小二乘回归分析" class="headerlink" title="偏最小二乘回归分析"></a>偏最小二乘回归分析</h2><ul><li>通过从自变量和因变量中提取成分来求解多对多的回归建模($P_{355}$)</li></ul><h2 id="现代优化算法"><a href="#现代优化算法" class="headerlink" title="现代优化算法"></a>现代优化算法</h2><ul><li><p>模拟退火算法($P_{367}$)</p></li><li><p>遗传算法($P_{373}$)</p></li></ul><h2 id="综合评价和决策方法"><a href="#综合评价和决策方法" class="headerlink" title="综合评价和决策方法"></a>综合评价和决策方法</h2><ul><li><p>确定多属性的权值算法</p><ul><li><p>TOPSIS算法：通过距离正理想解和负理想解的距离来判断($P_{411}$)</p></li><li><p>模糊综合方法：不受主观因素影响，可用于人才资源评测($P_{416}$)</p></li></ul></li><li><p>数据包络分析：对多指标输入和多指标输出有效($P_{410}$)</p></li><li><p>灰色关联分析($P_{424}$)</p></li><li><p>主成分分析($P_{427}$)</p></li><li><p>秩和比综合评价($P_{430}$)</p></li><li><p>熵权法评价($P_{432}$)</p></li><li><p>PageRank算法：搜索引擎检测结果排序算法($P_{434}$)</p></li></ul><h2 id="预测方法"><a href="#预测方法" class="headerlink" title="预测方法"></a>预测方法</h2><ul><li><p>根据已有数据对未来一段时间的数据进行预测</p></li><li><p>微分方程模型($P_{448}$)</p></li><li><p>灰色预测模型($P_{450}$)</p></li><li><p>马尔可夫预测模型：下一步发生的概率与历史的数据无关，仅仅与当前位置有关($P_{460}$)</p></li><li><p>时间序列</p><ul><li>检验时间序列是否平稳的Daniel算法($P_{466}$)</li></ul></li><li><p>插值与拟合($P_{469}$)</p></li><li><p>神经网络($P_{473}$)</p></li><li><p>通过元胞自动机来模拟传播并且进行预测</p></li></ul><h2 id="多目标规划"><a href="#多目标规划" class="headerlink" title="多目标规划"></a>多目标规划</h2><ul><li>即有多个目标函数，求解对于所有目标函数最小或者最大的最优解问题</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数学建模算法与应用算法分类与总结&quot;&gt;&lt;a href=&quot;#数学建模算法与应用算法分类与总结&quot; class=&quot;headerlink&quot; title=&quot;数学建模算法与应用算法分类与总结&quot;&gt;&lt;/a&gt;数学建模算法与应用算法分类与总结&lt;/h1&gt;&lt;h2 id=&quot;模型建立方法以及流</summary>
      
    
    
    
    <category term="数学建模" scheme="https://xianmengxi.github.io/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
    
    <category term="美赛" scheme="https://xianmengxi.github.io/tags/%E7%BE%8E%E8%B5%9B/"/>
    
    <category term="数学建模" scheme="https://xianmengxi.github.io/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
  </entry>
  
  <entry>
    <title>弹道方程以及代码实现</title>
    <link href="https://xianmengxi.github.io/2022/02/15/dan-dao-fang-cheng-yuan-li/"/>
    <id>https://xianmengxi.github.io/2022/02/15/dan-dao-fang-cheng-yuan-li/</id>
    <published>2022-02-15T02:00:00.000Z</published>
    <updated>2023-11-21T12:33:36.521Z</updated>
    
    <content type="html"><![CDATA[<h1 id="弹道方程以及代码实现"><a href="#弹道方程以及代码实现" class="headerlink" title="弹道方程以及代码实现"></a>弹道方程以及代码实现</h1><h2 id="什么是弹道方程？"><a href="#什么是弹道方程？" class="headerlink" title="什么是弹道方程？"></a>什么是弹道方程？</h2><p>弹道方程，就是使用数学模型来量化子弹在空气阻力作用下的运动轨迹。这听起来十分复杂，但其实际上其算法核心是依托于我们初中学过的斜抛运动,并没有想象之中的那么深奥。</p><p><img src="/2022/02/15/dan-dao-fang-cheng-yuan-li/1.png" alt="弹道示意图"></p><p>现在，我们假设子弹从A点出发，需要击打B点，在重力加速度和空气阻力的作用下，我们不可能使子弹的初速度直接指向AB方向，而是使子弹的发射方向偏离AC方向$\alpha$角度，这样才能确保子弹能以优美的弧线直接击打中B点。弹道方程的核心便是求解$\alpha$角</p><h2 id="忽略空气阻力的弹道方程建模"><a href="#忽略空气阻力的弹道方程建模" class="headerlink" title="忽略空气阻力的弹道方程建模"></a>忽略空气阻力的弹道方程建模</h2><ol><li><p>首先对初速度V进行速度分解</p><p> $$<br> \begin{cases}<br>     v_x&#x3D;v\cos\alpha \<br>     v_y&#x3D;v\sin\alpha<br> \end{cases}<br> $$</p></li><li><p>由于水平上不受力的作用(忽略了空气阻力),故</p><ul><li><p>飞行时间 $t&#x3D;\frac{f}{v_x}&#x3D;\frac{f}{v\cos\alpha}$ (f为如图的水平距离)</p></li><li><p>子弹击打中的高度<br> $$<br>  h &#x3D; v_y t - \frac{1}{2} g t^2&#x3D;v \sin \alpha * \frac{f}{v \cos \alpha} - \frac{1}{2} g * (\frac{f}{v \cos \alpha})^2&#x3D;f \tan \alpha - \frac{1}{2} g * (\frac{f}{v \cos \alpha})^2<br> $$</p></li></ul></li><li><p>求解：先来分析已知条件以及目的参数，我们已经计算得到了B点相对于A点的位置，那么h和f已知，有重力加速度已知，目标是求解$\alpha$,这容易得到$\alpha$的解析式，下面利用高斯牛顿法迭代求解$\alpha$</p></li><li><p>高斯牛顿法求解方程</p><ul><li><p>首先构造残差函数</p><p>  $$<br>  \lvert\lvert e \rvert\rvert ^2 &#x3D; \lvert\lvert h_{actual}-h_{calc} \rvert\rvert ^2<br>  $$</p><p>  其中$ h_{actual} $ 为已知值， $ h_{calc} $ 是使用迭代法逐渐逼近的h值</p><p>  我们的目标是</p><p>  $$<br>  \min \lvert\lvert e \rvert\rvert ^2 &#x3D; \lvert\lvert h_{actual}-h_{calc} \rvert\rvert ^2 &#x3D; \lvert\lvert h_{actual} - f\tan\alpha+\frac{1}{2}g*(\frac{f}{v\cos\alpha})^2 \rvert\rvert ^2<br>  $$</p><p>  以此来达到使用计算机迭代逼近$ h_{actual} $的目的</p></li><li><p>对误差函数e进行泰勒展开，则：</p><p>  $$<br>  e(\alpha + \Delta\alpha)&#x3D;e(\alpha)+\frac{\delta e}{\delta \alpha} * \Delta \alpha<br>  $$</p></li><li><p>那么近似的误差函数可以写为(对内部进行泰勒展开并且将整个式子展开)</p><p>  $$<br>  \lvert\lvert e(\alpha + \Delta\alpha) \rvert\rvert ^2 &#x3D; e^2 + 2e \frac{\delta e}{\delta \alpha} \Delta\alpha + (\frac{\delta e}{\delta \alpha} )^2 (\Delta \alpha)^2<br>  $$</p></li><li><p>对于这个方程,$ e(\alpha + \Delta\alpha) $ 表示当e加上一个微小变量时e的变化幅度，当e最小时，有那么$ \frac {d e(\alpha + \Delta\alpha)}{d \Delta \alpha} &#x3D; 0 $ ,解得 </p><p>  $$<br>  \Delta \alpha &#x3D; -\frac{e}{\frac{\delta e}{\delta\alpha}}<br>  $$</p></li><li><p>$\Delta \theta$变化的方向是使误差函数趋于最小值的方向，那么</p><p>  $$<br>  \alpha_{updata}&#x3D; \alpha + \Delta\alpha<br>  $$</p></li></ul></li><li><p>完整流程图</p></li></ol><p><img src="/2022/02/15/dan-dao-fang-cheng-yuan-li/2.png" alt="牛顿法迭代流程图"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;弹道方程以及代码实现&quot;&gt;&lt;a href=&quot;#弹道方程以及代码实现&quot; class=&quot;headerlink&quot; title=&quot;弹道方程以及代码实现&quot;&gt;&lt;/a&gt;弹道方程以及代码实现&lt;/h1&gt;&lt;h2 id=&quot;什么是弹道方程？&quot;&gt;&lt;a href=&quot;#什么是弹道方程？&quot; cla</summary>
      
    
    
    
    <category term="RoboMaster" scheme="https://xianmengxi.github.io/categories/RoboMaster/"/>
    
    
    <category term="RoboMaster" scheme="https://xianmengxi.github.io/tags/RoboMaster/"/>
    
    <category term="算法组" scheme="https://xianmengxi.github.io/tags/%E7%AE%97%E6%B3%95%E7%BB%84/"/>
    
    <category term="算法" scheme="https://xianmengxi.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="辅瞄" scheme="https://xianmengxi.github.io/tags/%E8%BE%85%E7%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Numpy实现卷积神经网络</title>
    <link href="https://xianmengxi.github.io/2021/12/26/numpy-shi-xian-juan-ji-shen-jing-wang-luo/"/>
    <id>https://xianmengxi.github.io/2021/12/26/numpy-shi-xian-juan-ji-shen-jing-wang-luo/</id>
    <published>2021-12-26T02:00:00.000Z</published>
    <updated>2023-11-21T12:02:08.708Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Numpy实现卷积神经网络"><a href="#Numpy实现卷积神经网络" class="headerlink" title="Numpy实现卷积神经网络"></a>Numpy实现卷积神经网络</h1><p>随着TensorFlow以及Pytorch等框架的兴起，使用Numpy实现神经网络似乎是一件既繁琐又效率低的一种方式。不过，作为一个刚接触深度学习领域的小白，要秉承着从头造轮子的思想来学习。刚好Python课设要求，利用课余时间总共7days，完成了使用Numpy实现卷积神经网络，更加深刻地理解了各层的原理以及作用。</p><p>代码地址: <a href="https://gitee.com/XianMengxi/NeturalNetwork">闲梦溪-Numpy实现卷积神经网络</a></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Numpy实现卷积神经网络&quot;&gt;&lt;a href=&quot;#Numpy实现卷积神经网络&quot; class=&quot;headerlink&quot; title=&quot;Numpy实现卷积神经网络&quot;&gt;&lt;/a&gt;Numpy实现卷积神经网络&lt;/h1&gt;&lt;p&gt;随着TensorFlow以及Pytorch等框架的兴</summary>
      
    
    
    
    <category term="课设" scheme="https://xianmengxi.github.io/categories/%E8%AF%BE%E8%AE%BE/"/>
    
    
    <category term="Python" scheme="https://xianmengxi.github.io/tags/Python/"/>
    
    <category term="课设" scheme="https://xianmengxi.github.io/tags/%E8%AF%BE%E8%AE%BE/"/>
    
    <category term="神经网络" scheme="https://xianmengxi.github.io/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
    <category term="算法组" scheme="https://xianmengxi.github.io/tags/%E7%AE%97%E6%B3%95%E7%BB%84/"/>
    
  </entry>
  
</feed>
